;;; Compiled snippets and support files for `src'
;;; Snippet definitions:
;;;
(yas-define-snippets 'src
                     '(("util.zig"
                        "pub const math = @import(\"util/math.zig\");\nconst mat4 = math.Mat4;\nconst shd = @import(\"shaders/basic.glsl.zig\");\nconst ig = @import(\"cimgui\");\n\npub fn computeVsParams(proj: mat4, view: mat4) shd.VsParams {\n    const model = mat4.identity();\n    //const rxm = mat4.rotate(rx, .{ .x = 1.0, .y = 0.0, .z = 0.0 });\n    //const rym = mat4.rotate(ry, .{ .x = 0.0, .y = 1.0, .z = 0.0 });\n    //const model = mat4.mul(rxm, rym);\n    //const aspect = app.widthf() / app.heightf();\n    //const proj = mat4.persp(60, aspect, 0.01, 100);\n    return shd.VsParams{ .mvp = mat4.mul(mat4.mul(proj, view), model) };\n}\n\npub fn aabb(point: ig.ImVec2_t, pos: ig.ImVec2_t, size: ig.ImVec2_t) bool {\n    const is_point_inside = point.x >= pos.x and point.x <= pos.x + size.x and\n        point.y >= pos.y and point.y <= pos.y + size.y;\n    return is_point_inside;\n}\n\npub const Interpolations = struct {\n    pub fn lerpVec2i(vec1: math.Vec2i, vec2: math.Vec2i) f32 {\n        _ = vec1;\n        _ = vec2;\n    }\n};\n"
                        "util.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/util.zig"
                        nil nil)
                       ("types.zig"
                        "/// Uniform types that are used by both the engine and game\nconst std = @import(\"std\");\npub const Entity = @import(\"types/entity.zig\");\npub const Tile = @import(\"types/tile.zig\");\npub const Scene = @import(\"types/scene.zig\");\npub const RendererTypes = @import(\"types/renderer.zig\");\n"
                        "types.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/types.zig"
                        nil nil)
                       ("storydb.zig" "" "storydb.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/storydb.zig"
                        nil nil)
                       ("state.zig"
                        "const std = @import(\"std\");\nconst RenderPass = @import(\"renderer.zig\").RenderPass;\nconst types = @import(\"types.zig\");\nconst Scene = types.Scene;\nconst Entity = types.Entity;\nconst shd = @import(\"shaders/basic.glsl.zig\");\nconst math = @import(\"util/math.zig\");\nconst Renderer = @import(\"renderer.zig\");\nconst assert = std.debug.assert;\n\npub const pass_count: u32 = 4;\n\n/// === GLOBAL STATE ===\nconst Self = @This();\nallocator: std.mem.Allocator,\nrenderer: Renderer,\npasses: []RenderPass,\nloaded_scene: ?Scene,\nselected_tile: ?usize,\nselected_tile_click: bool = false,\nselected_entity: ?usize,\nselected_entity_click: bool = false,\n\npub fn init(self: *Self, allocator: std.mem.Allocator) !void {\n    self.* = .{\n        .allocator = allocator,\n        .renderer = undefined,\n        .passes = try allocator.alloc(RenderPass, pass_count),\n        .loaded_scene = null,\n        .selected_entity = null,\n        .selected_tile = null,\n    };\n\n    try self.renderer.init(allocator);\n}\n\npub fn resetRenderPasses(self: *Self) !void {\n    for (self.passes) |pass| {\n        pass.batch.clearAndFree();\n        pass.cur_num_of_sprite = 0;\n    }\n}\n\npub fn updateBuffers(self: *Self) void {\n    for (self.renderer.render_passes.items) |*pass| {\n        if (pass.batch.items.len > 0) {\n            pass.updateBuffers();\n        }\n    }\n}\n\npub fn render(self: *Self, vs_params: shd.VsParams) void {\n    assert(self.loaded_scene != null);\n    for (self.renderer.render_passes.items) |*pass| {\n        pass.render(vs_params);\n    }\n}\n\npub fn collision(self: *Self, world_space: math.Vec4) void {\n    for (0.., self.renderer.render_passes.items[0].batch.items) |i, b| {\n        if (b.pos.x < world_space.x and b.pos.x + 16 > world_space.x) {\n            if (b.pos.y < world_space.y and b.pos.y + 16 > world_space.y) {\n                self.selected_tile = i;\n            }\n        }\n    }\n}\n"
                        "state.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/state.zig"
                        nil nil)
                       ("shaders.zig"
                        "pub const Basic = @import(\"shaders/basic.glsl.zig\");\n\npub const Tags = enum { basic };\n\npub const Shaders = union(Tags) {\n    basic: Basic,\n};\n"
                        "shaders.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/shaders.zig"
                        nil nil)
                       ("serde.zig"
                        "const types = @import(\"types.zig\");\nconst Scene = types.Scene;\nconst Entity = types.Entity;\nconst Tile = types.Tile;\nconst std = @import(\"std\");\nconst assert = std.debug.assert;\nconst Renderer = @import(\"renderer.zig\");\nconst log = std.log.scoped(.serde);\n\nfn multiArrayListToArray(comptime T: type, allocator: std.mem.Allocator, list: std.MultiArrayList(T)) ![]T {\n    const slice = list.slice();\n    const len = slice.len;\n\n    var result = try allocator.alloc(T, len);\n\n    for (0..len) |i| {\n        result[i] = slice.get(i);\n    }\n\n    return result;\n}\n\nconst SceneJson = struct {\n    const Self = @This();\n    id: u32,\n    height: f32,\n    width: f32,\n    scene_name: []const u8,\n    entities: []Entity,\n    tiles: []Tile,\n\n    pub fn sceneToSceneJson(scene: *Scene, allocator: std.mem.Allocator) !SceneJson {\n        const entities = try multiArrayListToArray(Entity, allocator, scene.entities);\n        const tiles = try multiArrayListToArray(Tile, allocator, scene.tiles);\n        return SceneJson{\n            .id = scene.id,\n            .height = scene.height,\n            .width = scene.width,\n            .scene_name = scene.scene_name,\n            .entities = entities,\n            .tiles = tiles,\n        };\n    }\n\n    pub fn sceneJsonToScene(self: *SceneJson, allocator: std.mem.Allocator) !Scene {\n        var entities = std.MultiArrayList(Entity){};\n        var tiles = std.MultiArrayList(Tile){};\n\n        for (self.entities) |e| {\n            try entities.append(allocator, e);\n        }\n        for (self.tiles) |e| {\n            try tiles.append(allocator, e);\n        }\n\n        return .{\n            .id = self.id,\n            .height = self.height,\n            .width = self.width,\n            .scene_name = self.scene_name,\n            .entities = entities,\n            .tiles = tiles,\n        };\n    }\n};\n\npub fn writeSceneToBinary(scene: *Scene, file_name: []const u8) !void {\n    assert(file_name.len > 0);\n    var level_dir = try std.fs.cwd().openDir(\"levels\", .{});\n\n    var file = try level_dir.createFile(file_name, .{});\n    defer file.close();\n\n    _ = try file.write(&std.mem.toBytes(scene.id));\n    _ = try file.write(\"\\n\");\n    _ = try file.write(&std.mem.toBytes(scene.width));\n    _ = try file.write(\"\\n\");\n    _ = try file.write(&std.mem.toBytes(scene.height));\n    _ = try file.write(\"\\n\");\n    _ = try file.write(scene.scene_name);\n    _ = try file.write(\"\\n\");\n\n    _ = try file.write(&std.mem.toBytes(scene.entities.len));\n    _ = try file.write(\"\\n\");\n    for (0..scene.entities.len) |t| {\n        _ = try file.write(&std.mem.toBytes(scene.entities.get(t)));\n    }\n\n    _ = try file.write(&std.mem.toBytes(scene.tiles.len));\n    _ = try file.write(\"\\n\");\n    for (0..scene.tiles.len) |t| {\n        _ = try file.write(&std.mem.toBytes(scene.tiles.get(t)));\n    }\n}\n\npub fn loadSceneFromBinary(scene: *Scene, file_name: []const u8, allocator: std.mem.Allocator) !void {\n    assert(file_name.len > 0);\n    var level_dir = try std.fs.cwd().openDir(\"levels\", .{});\n\n    var file = try level_dir.openFile(file_name, .{});\n    defer file.close();\n\n    var buf: [4096]u8 = undefined;\n    var reader = file.reader();\n\n    const scene_id_buf = try reader.readUntilDelimiter(&buf, '\\n');\n    scene.id = std.mem.bytesToValue(u32, scene_id_buf);\n\n    // Read scene width\n    const scene_width_buf = try reader.readUntilDelimiter(&buf, '\\n');\n    scene.width = std.mem.bytesToValue(f32, scene_width_buf);\n\n    // Read scene height\n    const scene_height_buf = try reader.readUntilDelimiter(&buf, '\\n');\n    scene.height = std.mem.bytesToValue(f32, scene_height_buf);\n\n    // Read scene name\n    const name_buf = try reader.readUntilDelimiter(&buf, '\\n');\n    scene.scene_name = try allocator.dupe(u8, name_buf);\n\n    const entity_count = try reader.readInt(usize, .little);\n    log.info(\"Entity count: {}\", .{entity_count});\n    try scene.entities.setCapacity(allocator, entity_count);\n    _ = try reader.readUntilDelimiter(&buf, '\\n');\n    for (0..entity_count) |_| {\n        var entity_buf: [@sizeOf(Entity)]u8 = undefined;\n        const len = try reader.readAtLeast(&entity_buf, @sizeOf(Entity));\n        const entity: Entity = std.mem.bytesToValue(Entity, entity_buf[0..len]);\n        try scene.entities.append(allocator, entity);\n    }\n\n    const tile_count = try reader.readInt(usize, .little);\n    log.info(\"Tile count: {}\", .{tile_count});\n    try scene.tiles.setCapacity(allocator, tile_count);\n    _ = try reader.readUntilDelimiter(&buf, '\\n');\n    for (0..tile_count) |_| {\n        var tile_buf: [@sizeOf(Tile)]u8 = undefined;\n        const len = try reader.readAtLeast(&tile_buf, @sizeOf(Tile));\n        const tile: Tile = std.mem.bytesToValue(Tile, tile_buf[0..len]);\n        try scene.tiles.append(allocator, tile);\n    }\n}\n\npub fn loadSceneFromJson(\n    scene: *Scene,\n    file_name: []const u8,\n    allocator: std.mem.Allocator,\n) !void {\n    assert(file_name.len > 0);\n    var level_dir = try std.fs.cwd().openDir(\"levels\", .{});\n\n    var file = try level_dir.openFile(file_name, .{});\n    defer file.close();\n\n    var reader = file.reader();\n\n    const file_buf = try reader.readAllAlloc(allocator, 10_000_000);\n    var scene_json: SceneJson = undefined;\n    scene_json = try std.json.parseFromSliceLeaky(SceneJson, allocator, file_buf, .{ .allocate = .alloc_always });\n\n    scene.* = try scene_json.sceneJsonToScene(allocator);\n}\n\npub fn writeSceneToJson(\n    scene: *Scene,\n    file_name: []const u8,\n    allocator: std.mem.Allocator,\n) !void {\n    assert(file_name.len > 0);\n    var level_dir = try std.fs.cwd().openDir(\"levels\", .{});\n\n    var file = try level_dir.createFile(file_name, .{});\n    defer file.close();\n\n    var writer = file.writer();\n\n    const stringified = try std.json.stringifyAlloc(allocator, try SceneJson.sceneToSceneJson(scene, allocator), .{ .whitespace = .indent_1 });\n\n    try writer.writeAll(stringified);\n}\n"
                        "serde.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/serde.zig"
                        nil nil)
                       ("scripting.zig"
                        "const Lua = @import(\"scripting/lua.zig\");"
                        "scripting.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/scripting.zig"
                        nil nil)
                       ("resource.zig" "" "resource.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/resource.zig"
                        nil nil)
                       ("renderer.zig"
                        "const std = @import(\"std\");\nconst sokol = @import(\"sokol\");\nconst util = @import(\"util.zig\");\nconst math = util.math;\nconst shd = @import(\"shaders/basic.glsl.zig\");\nconst cim = @cImport({\n    @cInclude(\"stb_image.h\");\n});\nconst sg = sokol.gfx;\nconst types = @import(\"types.zig\");\nconst SpriteRenderable = types.RendererTypes.SpriteRenderable;\nconst RenderPassIds = types.RendererTypes.RenderPassIds;\npub const RenderPass = @import(\"renderer/RenderPass.zig\");\nconst RenderConfigs = @import(\"renderer/RenderConfigs.zig\");\nconst log = std.log.scoped(.renderer);\n\nconst Self = @This();\nallocator: std.mem.Allocator,\nrender_passes: std.ArrayList(RenderPass),\nbasic_shd_vs_params: shd.VsParams,\n\npub fn init(self: *Self, allocator: std.mem.Allocator) !void {\n    log.info(\"Initializing Renderer\", .{});\n    self.allocator = allocator;\n    self.render_passes = std.ArrayList(RenderPass).init(self.allocator);\n\n    for (RenderConfigs.Defaults) |config| {\n        var pass: RenderPass = undefined;\n        try pass.init(\n            config.id,\n            config.path,\n            config.sprite_size,\n            config.atlas_size,\n            self.allocator,\n        );\n        log.debug(\"{any}\", .{pass});\n        try self.render_passes.append(pass);\n    }\n\n    for (self.render_passes.items) |pass| {\n        log.info(\"{s}\", .{pass.path});\n    }\n}\n\npub fn deinit(self: *Self) !void {\n    log.info(\"Deitializing Renderer\", .{});\n    self.render_passes.deinit();\n}\n"
                        "renderer.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/renderer.zig"
                        nil nil)
                       ("physics.zig" "" "physics.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/physics.zig"
                        nil nil)
                       ("main.zig"
                        "const std = @import(\"std\");\nconst ig = @import(\"cimgui\");\nconst sokol = @import(\"sokol\");\nconst app = sokol.app;\nconst sg = sokol.gfx;\nconst slog = sokol.log;\nconst glue = sokol.glue;\nconst imgui = sokol.imgui;\nconst shd = @import(\"shaders/basic.glsl.zig\");\nconst util = @import(\"util.zig\");\nconst math = util.math;\nconst mat4 = math.Mat4;\nconst RenderPass = @import(\"renderer.zig\").RenderPass;\nconst types = @import(\"types.zig\");\nconst Scene = types.Scene;\nconst Entity = types.Entity;\nconst State = @import(\"state.zig\");\nconst Serde = @import(\"serde.zig\");\nconst AudioDriver = @import(\"audio.zig\");\nconst Console = @import(\"editor/console.zig\");\n\npub const std_options: std.Options = .{\n    // Set the log level to info\n    .log_level = .info,\n\n    // Define logFn to override the std implementation\n    .logFn = customLogFn,\n};\n\npub fn customLogFn(\n    comptime level: std.log.Level,\n    comptime scope: @Type(.enum_literal),\n    comptime format: []const u8,\n    args: anytype,\n) void {\n    const prefix = \"[\" ++ comptime level.asText() ++ \"] \" ++ \"(\" ++ @tagName(scope) ++ \"):\\t\";\n\n    // Print the message to stderr, silently ignoring any errors\n    std.debug.lockStdErr();\n    defer std.debug.unlockStdErr();\n    const stderr = std.io.getStdErr().writer();\n    nosuspend stderr.print(prefix ++ format ++ \"\\n\", args) catch return;\n}\n\nvar global_state: State = undefined;\nvar passaction: sg.PassAction = .{};\nvar proj: math.Mat4 = undefined;\nvar view: math.Mat4 = undefined;\nconst zoom_factor = 0.25;\nvar depth_image: sg.Image = .{};\nvar ad: AudioDriver = undefined;\nvar console: Console = undefined;\n\npub fn gameinit() !void {\n    var env = glue.environment();\n    env.defaults.color_format = .RGBA8;\n    env.defaults.depth_format = .DEPTH_STENCIL;\n    sg.setup(.{\n        .environment = env,\n        .logger = .{ .func = slog.func },\n    });\n\n    std.log.info(\"{s}\", .{@tagName(sg.queryDesc().environment.defaults.color_format)});\n\n    imgui.setup(.{\n        .logger = .{ .func = slog.func },\n    });\n\n    //try ad.init();\n\n    try global_state.init(std.heap.page_allocator);\n    try console.init(global_state.allocator);\n    var scene: Scene = .{};\n    try Serde.loadSceneFromBinary(&scene, \"t2.txt\", global_state.allocator);\n    global_state.loaded_scene = scene;\n    try global_state.loaded_scene.?.loadScene(&global_state.renderer);\n    std.log.info(\"{}\", .{global_state.loaded_scene.?.tiles.len});\n    passaction.colors[0] = .{\n        .load_action = .CLEAR,\n        .clear_value = .{ .r = 0, .g = 0, .b = 0, .a = 0 },\n    };\n    proj = mat4.ortho(\n        -app.widthf() / 2 * zoom_factor + 50,\n        app.widthf() / 2 * zoom_factor + 50,\n        -app.heightf() / 2 * zoom_factor - 50,\n        app.heightf() / 2 * zoom_factor - 50,\n        -1,\n        1,\n    );\n    view = math.Mat4.identity();\n}\n\npub fn gameframe() !void {\n    imgui.newFrame(.{\n        .width = app.width(),\n        .height = app.height(),\n        .delta_time = app.frameDuration(),\n        .dpi_scale = app.dpiScale(),\n    });\n    const viewport = ig.igGetMainViewport();\n    viewport.*.Flags |= ig.ImGuiViewportFlags_NoRendererClear;\n\n    ig.igSetNextWindowPos(viewport.*.WorkPos, ig.ImGuiCond_Always);\n    ig.igSetNextWindowSize(viewport.*.WorkSize, ig.ImGuiCond_Always);\n    ig.igSetNextWindowViewport(viewport.*.ID);\n\n    if (console.open) {\n        ig.igSetNextWindowPos(.{ .x = 10, .y = 10 }, ig.ImGuiCond_Once);\n        ig.igSetNextWindowSize(.{ .x = 400, .y = 100 }, ig.ImGuiCond_Once);\n        try console.console(global_state.allocator);\n    }\n\n    var swapchain = glue.swapchain();\n    swapchain.color_format = .RGBA8;\n    global_state.updateBuffers();\n    sg.beginPass(.{ .action = passaction, .swapchain = swapchain });\n    global_state.render(util.computeVsParams(proj, view));\n    imgui.render();\n    sg.endPass();\n    sg.commit();\n}\npub fn gamecleanup() !void {}\npub fn gameevent(ev: [*c]const app.Event) !void {\n    if (ev.*.type == .KEY_UP or ev.*.type == .KEY_DOWN) {\n        switch (ev.*.key_code) {\n            .A => console.open = true,\n            .B => console.open = false,\n            .ESCAPE => app.quit(),\n            else => {},\n        }\n    }\n}\nexport fn init() void {\n    gameinit() catch unreachable;\n}\n\nexport fn frame() void {\n    gameframe() catch unreachable;\n}\n\nexport fn cleanup() void {\n    ad.deinit();\n    gamecleanup() catch unreachable;\n}\nexport fn event(ev: [*c]const app.Event) void {\n    gameevent(ev) catch unreachable;\n}\n\npub fn main() !void {\n    var desc: app.Desc = undefined;\n\n    desc = .{\n        .init_cb = init,\n        .frame_cb = frame,\n        .event_cb = event,\n        .cleanup_cb = cleanup,\n        .width = 1200,\n        .height = 800,\n        .window_title = \"HELLO\",\n    };\n\n    app.run(desc);\n}\n"
                        "main.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/main.zig"
                        nil nil)
                       ("editor.zig"
                        "/// === EDITOR ===\n/// This is the entire editor in a single file basically.\n/// It may be split apart later, but for now its completely\n/// fine.\nconst std = @import(\"std\");\nconst ig = @import(\"cimgui\");\nconst sokol = @import(\"sokol\");\nconst app = sokol.app;\nconst sg = sokol.gfx;\nconst slog = sokol.log;\nconst glue = sokol.glue;\nconst imgui = sokol.imgui;\nconst State = @import(\"state.zig\");\nconst util = @import(\"util.zig\");\nconst math = util.math;\nconst mat4 = math.Mat4;\nconst Lua = @import(\"scripting/lua.zig\");\nconst types = @import(\"types.zig\");\nconst RenderPassIds = types.RendererTypes.RenderPassIds;\nconst Scene = types.Scene;\nconst Entity = types.Entity;\nconst Tile = types.Tile;\nconst Serde = @import(\"serde.zig\");\nconst Quad = @import(\"renderer/RenderQuad.zig\");\nconst TypeEditors = @import(\"editor/entity_editor.zig\");\nconst Console = @import(\"editor/console.zig\");\n\npub const std_options: std.Options = .{\n    // Set the log level to info\n    .log_level = .info,\n\n    // Define logFn to override the std implementation\n    .logFn = customLogFn,\n};\n\npub fn customLogFn(\n    comptime level: std.log.Level,\n    comptime scope: @Type(.enum_literal),\n    comptime format: []const u8,\n    args: anytype,\n) void {\n    const prefix = \"[\" ++ comptime level.asText() ++ \"] \" ++ \"(\" ++ @tagName(scope) ++ \"):\\t\";\n\n    // Print the message to stderr, silently ignoring any errors\n    std.debug.lockStdErr();\n    defer std.debug.unlockStdErr();\n    const stderr = std.io.getStdErr().writer();\n    nosuspend stderr.print(prefix ++ format ++ \"\\n\", args) catch return;\n}\nconst predefined_colors = [_]ig.ImVec4_t{\n    .{ .x = 1.0, .y = 0.0, .z = 0.0, .w = 1.0 }, // red\n    .{ .x = 0.0, .y = 1.0, .z = 0.0, .w = 1.0 }, // green\n    .{ .x = 0.0, .y = 0.0, .z = 1.0, .w = 1.0 }, // blue\n    .{ .x = 1.0, .y = 1.0, .z = 0.0, .w = 1.0 }, // yellow\n    .{ .x = 1.0, .y = 1.0, .z = 1.0, .w = 1.0 }, // white\n    .{ .x = 0.0, .y = 0.0, .z = 0.0, .w = 1.0 }, // black\n};\n\npub const Input = struct {\n    up: bool = false,\n    down: bool = false,\n    left: bool = false,\n    right: bool = false,\n    forward: bool = false,\n    backwards: bool = false,\n};\n\npub const MouseState = struct {\n    hover_over_scene: bool = false,\n};\n\nconst SerdeMode = enum {\n    JSON,\n    BINARY,\n};\n\npub const EditorConfig = struct {\n    mode: SerdeMode = .BINARY,\n\n    pub fn loadConfig(\n        self: *EditorConfig,\n        allo: std.mem.Allocator,\n    ) !void {\n        var cwd = std.fs.cwd();\n\n        var config_file = try cwd.openFile(\"editor.json\", .{});\n        defer config_file.close();\n\n        const config_buf = try config_file.readToEndAlloc(allo, 1000);\n\n        const temp = try std.json.parseFromSliceLeaky(EditorConfig, allo, config_buf, .{});\n        self.mode = temp.mode;\n    }\n};\n\nvar history_buf: std.ArrayList([]const u8) = undefined;\n\npub const EditorState = struct {\n    gpa: std.heap.GeneralPurposeAllocator(.{}),\n    allocator: std.mem.Allocator = undefined,\n    view: math.Mat4 = undefined,\n    proj: math.Mat4 = undefined,\n    mouse_state: MouseState = .{},\n    editor_scene_image: sg.Image = .{},\n    editor_scene_image_depth: sg.Image = .{},\n    attachment: sg.Attachments = .{},\n    editor_config: EditorConfig = .{},\n    zoom_factor: f32 = 0.25,\n    selected_layer: RenderPassIds = .TILES_1,\n    state: State = undefined,\n    console: Console = undefined,\n\n    pub fn init(self: *EditorState) !void {\n        const gpa = std.heap.GeneralPurposeAllocator(.{}){};\n        const allocator = std.heap.page_allocator;\n        var s: State = undefined;\n        try s.init(allocator);\n        var c: Console = undefined;\n        try c.init(allocator);\n        self.* = .{\n            .gpa = gpa,\n            .allocator = allocator,\n            .view = math.Mat4.identity(),\n            .proj = mat4.ortho(\n                -app.widthf() / 2 * zoom_factor + 50,\n                app.widthf() / 2 * zoom_factor + 50,\n                -app.heightf() / 2 * zoom_factor - 50,\n                app.heightf() / 2 * zoom_factor - 50,\n                -1,\n                1,\n            ),\n            .state = s,\n            .selected_layer = .TILES_1,\n            .console = c,\n        };\n    }\n};\n\n// @todo Move Imgui rendering to a seperate function\npub fn imguiRender() void {}\n\nvar es: EditorState = undefined;\nvar mouse_middle_down: bool = false;\nvar view: math.Mat4 = undefined;\nvar passaction: sg.PassAction = .{};\nvar offscreen: sg.PassAction = .{};\nvar image: sg.Image = .{};\nvar input: Input = .{};\nvar r: f32 = 0;\nvar proj: math.Mat4 = undefined;\nvar zoom_factor: f32 = 0.25;\nvar settings_docked: bool = false;\nvar attachment: sg.Attachments = .{};\nvar layout_initialized: bool = false;\nvar mouse_world_space: math.Vec4 = .{};\nvar scene_window_pos = ig.ImVec2_t{};\nvar scene_window_size = ig.ImVec2_t{};\nvar is_mouse_in_scene: bool = false;\nvar scene: Scene = undefined;\nvar buf: [8192]u8 = undefined;\nvar mouse_state: MouseState = .{};\nvar scene_list_buffer: std.ArrayList([]const u8) = undefined;\nvar new_temp_scene: Scene = .{};\nvar new_scene_open: bool = false;\nvar load_scene_open: bool = false;\nvar editor_config: EditorConfig = .{};\nvar console_buf: [8192]u8 = undefined;\n\nconst test_string = \"HELLO FROM HERE\";\n\nconst test_json =\n    \\\\{\n    \\\\    \"pos\": {\n    \\\\        \"x\": 0,\n    \\\\        \"y\": 0\n    \\\\    },\n    \\\\    \"sprite_renderable\": {\n    \\\\        \"pos\": {\n    \\\\            \"x\": 0e0,\n    \\\\            \"y\": 1e2,\n    \\\\            \"z\": 0e0\n    \\\\        },\n    \\\\        \"sprite_id\": 4.6e1,\n    \\\\        \"color\": {\n    \\\\            \"x\": 1e0,\n    \\\\            \"y\": 1e0,\n    \\\\            \"z\": 1e0,\n    \\\\            \"w\": 1e0\n    \\\\        }\n    \\\\    },\n    \\\\    \"spawner\": false,\n    \\\\    \"traversable\": false\n    \\\\}\n;\n\npub fn editorInit() !void {\n\n    // Default Projection matrix\n    proj = mat4.ortho(\n        -app.widthf() / 2 * zoom_factor + 50,\n        app.widthf() / 2 * zoom_factor + 50,\n        -app.heightf() / 2 * zoom_factor - 50,\n        app.heightf() / 2 * zoom_factor - 50,\n        -1,\n        1,\n    );\n    view = math.Mat4.identity();\n\n    sg.setup(.{\n        .environment = glue.environment(),\n        .logger = .{ .func = slog.func },\n    });\n\n    imgui.setup(.{\n        .logger = .{ .func = slog.func },\n        .ini_filename = \"imgui.ini\",\n    });\n    try es.init();\n    //const testtile = try std.json.parseFromSliceLeaky(Tile, allocator, test_json, .{});\n    //std.log.info(\"{any}\", .{testtile});\n    try editor_config.loadConfig(es.allocator);\n    //try Lua.luaTest();\n\n    scene_list_buffer = std.ArrayList([]const u8).init(es.allocator);\n    history_buf = std.ArrayList([]const u8).init(es.allocator);\n\n    const io = ig.igGetIO();\n    io.*.ConfigFlags |= ig.ImGuiConfigFlags_DockingEnable;\n    io.*.ConfigFlags |= ig.ImGuiConfigFlags_ViewportsEnable;\n    ig.igLoadIniSettingsFromDisk(io.*.IniFilename);\n\n    // While in the editor, we render the game to a texture. that\n    // texture is then rendered within an Imgui window.\n    var img_desc: sg.ImageDesc = .{\n        .render_target = true,\n        .width = 700,\n        .height = 440,\n        .pixel_format = .RGBA8,\n        .sample_count = 1,\n    };\n\n    // Image for scene needs both Image, and depth image\n    es.editor_scene_image = sg.makeImage(img_desc);\n\n    var attachment_desc: sg.AttachmentsDesc = .{};\n    attachment_desc.colors[0].image = es.editor_scene_image;\n    img_desc.pixel_format = .DEPTH_STENCIL;\n\n    es.editor_scene_image_depth = sg.makeImage(img_desc);\n    attachment_desc.depth_stencil.image = es.editor_scene_image_depth;\n\n    attachment = sg.makeAttachments(attachment_desc);\n\n    //try scene.loadTestScene(allocator, &state);\n    if (editor_config.mode == .BINARY) {\n        try scene.loadTestScene(es.allocator, &es.state);\n        //try Serde.loadSceneFromBinary(&scene, \"t2.txt\", std.heap.page_allocator);\n        try Serde.writeSceneToJson(&scene, \"t2.json\", std.heap.page_allocator);\n        es.state.loaded_scene = scene;\n    } else if (editor_config.mode == .JSON) {\n        try Serde.loadSceneFromJson(&scene, \"t2.json\", std.heap.page_allocator);\n        es.state.loaded_scene = scene;\n    }\n    try es.state.loaded_scene.?.loadScene(&es.state.renderer);\n\n    // Default pass actions\n    passaction.colors[0] = .{\n        .load_action = .CLEAR,\n        .clear_value = .{ .r = 0, .g = 0, .b = 0, .a = 0 },\n    };\n    offscreen.colors[0] = .{\n        .load_action = .CLEAR,\n        .clear_value = .{ .r = 0, .g = 0, .b = 0, .a = 0 },\n    };\n}\npub fn editorFrame() !void {\n\n    //view = math.Mat4.lookat(camera.pos, camera.pos.add(camera.front), camera.up);\n    //\n    //\n    // Imgui Frame setup\n    imgui.newFrame(.{\n        .width = app.width(),\n        .height = app.height(),\n        .delta_time = app.frameDuration(),\n        .dpi_scale = app.dpiScale(),\n    });\n\n    const viewport = ig.igGetMainViewport();\n    viewport.*.Flags |= ig.ImGuiViewportFlags_NoRendererClear;\n    const style = ig.igGetStyle();\n    style.*.Colors[ig.ImGuiCol_WindowBg] = ig.ImVec4_t{ .x = 0, .y = 0, .z = 0, .w = 0 };\n\n    const window_flags = ig.ImGuiWindowFlags_MenuBar |\n        ig.ImGuiWindowFlags_NoDocking |\n        ig.ImGuiWindowFlags_NoTitleBar |\n        ig.ImGuiWindowFlags_NoCollapse |\n        ig.ImGuiWindowFlags_NoResize |\n        ig.ImGuiWindowFlags_NoMove |\n        ig.ImGuiWindowFlags_NoBringToFrontOnFocus |\n        ig.ImGuiWindowFlags_NoNavFocus |\n        ig.ImGuiWindowFlags_NoBackground |\n        ig.ImGuiWindowFlags_NoInputs;\n\n    ig.igSetNextWindowPos(viewport.*.WorkPos, ig.ImGuiCond_Always);\n    ig.igSetNextWindowSize(viewport.*.WorkSize, ig.ImGuiCond_Always);\n    ig.igSetNextWindowViewport(viewport.*.ID);\n\n    try main_menu();\n\n    // Create a dockspace to enable window docking\n    _ = ig.igBegin(\"DockSpace\", null, window_flags);\n    const dockspace_id = ig.igGetIDStr(\"MyDockSpace\".ptr, null);\n    _ = ig.igDockSpace(dockspace_id);\n    ig.igSetNextWindowDockID(dockspace_id, ig.ImGuiCond_Once);\n    ig.igEnd();\n\n    // Game scene renderer. Game rendered to a texture\n    ig.igSetNextWindowDockID(dockspace_id, ig.ImGuiCond_Once);\n    _ = ig.igBegin(\"Scene\", 0, ig.ImGuiWindowFlags_None);\n    scene_window_pos = ig.igGetWindowPos();\n    scene_window_size = ig.igGetContentRegionAvail();\n    ig.igImage(imgui.imtextureid(es.editor_scene_image), ig.ImVec2{ .x = 700, .y = 440 });\n    ig.igEnd();\n\n    // Editor for Entity\n    _ = ig.igBegin(\"Entity Editor\", 0, ig.ImGuiWindowFlags_None);\n    if (es.selected_layer == .TILES_1 or es.selected_layer == .TILES_2) {\n        try TypeEditors.drawTileEditor(&es);\n    } else {\n        try TypeEditors.drawEntityEditor(&es);\n    }\n    ig.igEnd();\n\n    // Drawer for data. This is unused for now, but something will go here.\n    // Idea tab for animations, or Possible script viewer.\n    // @todo Move this to the console editor file.\n    try es.console.console(es.allocator);\n\n    //for (0..test_string.len) |i| {\n    //    const f: f32 = @floatFromInt(i);\n    //    try state.renderer.render_passes.items[@intFromEnum(RenderPassIds.UI_1)].appendSpriteToBatch(.{\n    //        .pos = .{ .x = f * 16 - 32, .y = 26, .z = 0 },\n    //        .sprite_id = @floatFromInt(test_string[i]),\n    //        .color = .{ .x = 0.1, .y = 1, .z = 0.5, .w = 1 },\n    //    });\n    //}\n\n    var clamped_mouse_pos: math.Vec3 = undefined;\n    if (mouse_state.hover_over_scene) {\n        const grid_size = 16.0;\n        const grid_offset_x = 0.0; // Adjust as needed\n        const grid_offset_y = 0.0; // Adjust as needed\n        clamped_mouse_pos = math.Vec3{\n            .x = @floor((mouse_world_space.x - grid_offset_x) / grid_size) * grid_size + grid_offset_x,\n            .y = @floor((mouse_world_space.y - grid_offset_y) / grid_size) * grid_size + grid_offset_y,\n            .z = 0,\n        };\n\n        try es.state.renderer.render_passes.items[@intFromEnum(RenderPassIds.UI_1)].appendSpriteToBatch(.{ .pos = clamped_mouse_pos, .sprite_id = 1, .color = .{ .x = 0, .y = 0, .z = 0, .w = 0 } });\n    }\n\n    try left_window();\n\n    // Prepare render data for instanced rendering\n    const vs_params = util.computeVsParams(proj, view);\n    es.state.updateBuffers();\n\n    // === Render scene to image\n    sg.beginPass(.{ .action = offscreen, .attachments = attachment });\n    if (es.state.loaded_scene) |_| {\n        es.state.render(vs_params);\n    }\n    if (!es.state.selected_tile_click) {\n        es.state.collision(mouse_world_space);\n    }\n    sg.endPass();\n\n    //Quad.drawQuad2dSpace(.{ .x = 10, .y = 10 }, .{ .x = 1, .y = 0, .z = 0 }, .{ .mvp = vs_params.mvp });\n\n    // === Render IMGUI windows\n    sg.beginPass(.{ .action = passaction, .swapchain = glue.swapchain() });\n    imgui.render();\n    sg.endPass();\n    sg.commit();\n    es.state.renderer.render_passes.items[@intFromEnum(RenderPassIds.UI_1)].batch.clearRetainingCapacity();\n    es.state.renderer.render_passes.items[@intFromEnum(RenderPassIds.UI_1)].cur_num_of_sprite = 0;\n}\n\npub fn editorCleanup() !void {\n    //ig.igSaveIniSettingsToDisk(\"imgui.ini\");\n    imgui.shutdown();\n}\n\npub fn editorEvent(ev: [*c]const app.Event) !void {\n    const eve = ev.*;\n\n    // forward input events to sokol-imgui\n    _ = imgui.handleEvent(ev.*);\n    const ig_mouse = ig.igGetMousePos();\n\n    if (util.aabb(ig_mouse, scene_window_pos, scene_window_size)) {\n        mouse_state.hover_over_scene = true;\n    } else {\n        mouse_state.hover_over_scene = false;\n    }\n\n    if (eve.type == .MOUSE_SCROLL) {\n        if (zoom_factor - 0.05 < 0) {\n            zoom_factor = 0.0;\n        }\n        if (eve.scroll_y > 0 and zoom_factor < 5) {\n            zoom_factor += 0.05;\n        }\n        if (eve.scroll_y < 0 and zoom_factor > 0) {\n            zoom_factor -= 0.05;\n        }\n        proj = mat4.ortho(\n            -app.widthf() / 2 * zoom_factor + 50,\n            app.widthf() / 2 * zoom_factor + 50,\n            -app.heightf() / 2 * zoom_factor - 50,\n            app.heightf() / 2 * zoom_factor - 50,\n            -1,\n            1,\n        );\n    }\n    if (ev.*.type == .MOUSE_MOVE) {\n        const mouse_rel_x = ig_mouse.x - scene_window_pos.x;\n        const mouse_rel_y = ig_mouse.y - scene_window_pos.y;\n\n        const texture_x = mouse_rel_x / 700.0;\n        const texture_y = mouse_rel_y / 440.0;\n\n        const ndc_x = texture_x * 2.0 - 1.0;\n        const ndc_y = 1.0 - texture_y * 2.0; // Flip Y for OpenGL-style coordinates\n\n        const view_proj = math.Mat4.mul(proj, view);\n        const inv = math.Mat4.inverse(view_proj);\n        mouse_world_space = math.Mat4.mulByVec4(inv, .{ .x = ndc_x, .y = ndc_y, .z = 0, .w = 1 });\n    }\n    if (ev.*.type == .MOUSE_MOVE and mouse_middle_down) {\n        view = math.Mat4.mul(view, math.Mat4.translate(.{\n            .x = zoom_factor * ev.*.mouse_dx,\n            .y = zoom_factor * -ev.*.mouse_dy,\n            .z = 0,\n        }));\n    }\n    if (ev.*.type == .MOUSE_DOWN or ev.*.type == .MOUSE_UP) {\n        const mouse_pressed = ev.*.type == .MOUSE_DOWN;\n        switch (ev.*.mouse_button) {\n            .MIDDLE => mouse_middle_down = mouse_pressed,\n            .LEFT => {\n                if (mouse_state.hover_over_scene) {\n                    if (es.state.selected_tile) |_| {\n                        es.state.selected_tile_click = true;\n                    }\n                }\n            },\n            .RIGHT => {\n                if (es.state.selected_tile_click) {\n                    es.state.selected_tile_click = false;\n                    es.state.selected_tile = null;\n                }\n            },\n\n            else => {},\n        }\n    }\n\n    if (ev.*.type == .KEY_UP or ev.*.type == .KEY_DOWN) {\n        const key_pressed = ev.*.type == .KEY_DOWN;\n        switch (ev.*.key_code) {\n            .LEFT => {\n                view = math.Mat4.mul(view, math.Mat4.translate(.{ .x = zoom_factor * -10, .y = zoom_factor * 0, .z = 0 }));\n            },\n            .RIGHT => {\n                view = math.Mat4.mul(view, math.Mat4.translate(.{ .x = zoom_factor * 10, .y = zoom_factor * 0, .z = 0 }));\n            },\n            .UP => {\n                view = math.Mat4.mul(view, math.Mat4.translate(.{ .x = zoom_factor * 0, .y = zoom_factor * 10, .z = 0 }));\n            },\n            .DOWN => {\n                view = math.Mat4.mul(view, math.Mat4.translate(.{ .x = zoom_factor * 0, .y = zoom_factor * -10, .z = 0 }));\n            },\n            .W => input.forward = key_pressed,\n            .S => input.backwards = key_pressed,\n            .A => input.left = key_pressed,\n            .D => input.right = key_pressed,\n            .ESCAPE => app.quit(),\n            else => {},\n        }\n    }\n}\n\nfn main_menu() !void {\n    if (ig.igBeginMainMenuBar()) {}\n    if (ig.igButton(\"Open Dropdown\")) {\n        ig.igOpenPopup(\"dropdown\", 0);\n    }\n\n    if (ig.igBeginPopup(\"dropdown\", 0)) {\n        if (ig.igButton(\"New Scenes\")) {\n            new_temp_scene = .{};\n            new_scene_open = true;\n            ig.igCloseCurrentPopup();\n        }\n        if (ig.igButton(\"Save Scenes\")) {\n            if (es.state.loaded_scene) |*s| {\n                try Serde.writeSceneToBinary(s, s.scene_name);\n            }\n            ig.igCloseCurrentPopup();\n        }\n        if (ig.igButton(\"Load Scene\")) {\n            var level_dir = try std.fs.cwd().openDir(\"levels\", .{});\n            var level_walker = try level_dir.walk(es.allocator);\n            while (try level_walker.next()) |entry| {\n                try scene_list_buffer.append(try es.allocator.dupe(u8, entry.basename));\n            }\n            level_walker.deinit();\n            load_scene_open = true;\n        }\n        ig.igEndPopup();\n    }\n    if (load_scene_open) {\n        ig.igSetNextWindowBgAlpha(1.0);\n        ig.igSetNextWindowSize(.{ .x = 300, .y = 200 }, ig.ImGuiCond_None);\n        if (ig.igBegin(\"Load Scene\", &load_scene_open, ig.ImGuiWindowFlags_NoSavedSettings | ig.ImGuiWindowFlags_NoDocking)) {\n            if (scene_list_buffer.items.len > 0) {\n                for (scene_list_buffer.items) |s| {\n                    if (ig.igButton(s.ptr)) {\n                        // @todo load a scene, and set the scene to the state loaded scene\n                        if (es.state.loaded_scene) |*loaded_scene| {\n                            loaded_scene.deloadScene(es.allocator, &es.state);\n                        }\n                        var temp_scene: Scene = .{};\n                        try Serde.loadSceneFromBinary(&temp_scene, s, es.allocator);\n                        es.state.loaded_scene = temp_scene;\n                        try es.state.loaded_scene.?.loadScene(&es.state.renderer);\n\n                        load_scene_open = false;\n                        scene_list_buffer.clearAndFree();\n                        break;\n                    }\n                }\n            }\n        }\n        ig.igEnd();\n    }\n\n    if (new_scene_open) {\n        ig.igSetNextWindowBgAlpha(1.0);\n        ig.igSetNextWindowSize(.{ .x = 300, .y = 200 }, ig.ImGuiCond_None);\n        if (ig.igBegin(\"New Scene\", &new_scene_open, ig.ImGuiWindowFlags_NoSavedSettings | ig.ImGuiWindowFlags_NoDocking)) {\n            if (ig.igInputText(\"Name\", &buf, buf.len, ig.ImGuiWindowFlags_None)) {\n                const temp_name: []const u8 = std.mem.span(@as([*c]u8, @ptrCast(buf[0..].ptr)));\n                new_temp_scene.scene_name = temp_name;\n            }\n            _ = ig.igInputFloat(\"Width\", &new_temp_scene.width);\n            _ = ig.igInputFloat(\"Height\", &new_temp_scene.height);\n            if (ig.igButton(\"New Scene\")) {\n                es.state.loaded_scene.?.deloadScene(es.allocator, &es.state);\n                try new_temp_scene.tiles.setCapacity(es.allocator, @as(usize, @intFromFloat(new_temp_scene.width * new_temp_scene.height)));\n                for (0..new_temp_scene.tiles.capacity) |i| {\n                    const f: f32 = @floatFromInt(i);\n                    new_temp_scene.tiles.insertAssumeCapacity(i, .{\n                        .sprite_renderable = .{\n                            .pos = .{\n                                .x = @mod(f, new_temp_scene.width) * 16,\n                                .y = @floor(f / new_temp_scene.height) * 16,\n                                .z = 0,\n                            },\n                            .sprite_id = 0,\n                            .color = .{\n                                .x = 1.0,\n                                .y = 1.0,\n                                .z = 1.0,\n                                .w = 1.0,\n                            },\n                        },\n                    });\n                }\n                es.state.loaded_scene = new_temp_scene;\n                try es.state.loaded_scene.?.loadScene(&es.state.renderer);\n                try Serde.writeSceneToBinary(&es.state.loaded_scene.?, es.state.loaded_scene.?.scene_name);\n                es.state.selected_tile = null;\n            }\n        }\n        ig.igEnd();\n    }\n\n    ig.igEndMainMenuBar();\n}\n\nfn left_window() !void {\n    // General Scene Settings\n    _ = ig.igBegin(\"Settings\", 0, ig.ImGuiWindowFlags_None);\n    ig.igBeginGroup();\n    ig.igTextColored(predefined_colors[1], \"Stats\");\n    const text = try std.fmt.allocPrint(es.allocator, \"frame duration: {d:.3}\", .{app.frameDuration()});\n    defer es.allocator.free(text);\n    ig.igText(text.ptr);\n    const render_pass_count = try std.fmt.allocPrint(es.allocator, \"RenderPass Count: {d}\", .{es.state.passes.len});\n    defer es.allocator.free(render_pass_count);\n    ig.igText(render_pass_count.ptr);\n\n    ig.igNewLine();\n    ig.igSameLine();\n    ig.igText(\"Selected Layer\");\n    ig.igText(@tagName(es.selected_layer));\n    for (std.meta.tags(RenderPassIds)) |id| {\n        if (ig.igButton(@tagName(id).ptr)) {\n            es.selected_layer = id;\n        }\n    }\n    ig.igEndGroup();\n    ig.igEnd();\n}\n\nexport fn init() void {\n    editorInit() catch unreachable;\n}\n\nexport fn frame() void {\n    editorFrame() catch unreachable;\n}\n\nexport fn cleanup() void {\n    editorCleanup() catch unreachable;\n}\nexport fn event(ev: [*c]const app.Event) void {\n    editorEvent(ev) catch unreachable;\n}\n\npub fn main() !void {\n    app.run(.{\n        .init_cb = init,\n        .frame_cb = frame,\n        .event_cb = event,\n        .cleanup_cb = cleanup,\n        .width = 1200,\n        .height = 800,\n        .window_title = \"HELLO\",\n    });\n}\n"
                        "editor.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/editor.zig"
                        nil nil)
                       ("audio.zig"
                        "const std = @import(\"std\");\nconst sokol = @import(\"sokol\");\nconst audio = sokol.audio;\nconst slog = sokol.log;\n\nvar sample_counter: u32 = 0;\n\nconst Self = @This();\ngpa: std.heap.GeneralPurposeAllocator(.{}),\nallocator: std.mem.Allocator,\nbuffer: []f32,\n\npub fn stream_cb(buffer: [*c]f32, num_frames: i32, num_channels: i32) callconv(.C) void {\n    const total_samples = @as(usize, @intCast(num_frames)) * @as(usize, @intCast(num_channels));\n    for (0..total_samples) |i| {\n        const phase = (sample_counter >> 3) & 1;\n        buffer[i] = if (phase == 0) 0.5 else -0.5;\n        sample_counter += 1;\n    }\n}\n\npub fn init(self: *Self) !void {\n    self.gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    self.allocator = self.gpa.allocator();\n    self.buffer = try self.allocator.alloc(f32, 1000);\n    audio.setup(.{\n        .stream_cb = stream_cb,\n        .logger = .{ .func = slog.func },\n    });\n}\n\npub fn deinit(self: *Self) void {\n    self.allocator.free(self.buffer);\n    _ = self.gpa.deinit();\n    audio.shutdown();\n}\n"
                        "audio.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/audio.zig"
                        nil nil)))


;;; Snippet definitions:
;;;
(yas-define-snippets 'src
                     '(("entity_editor.zig"
                        "const std = @import(\"std\");\nconst ig = @import(\"cimgui\");\nconst sokol = @import(\"sokol\");\nconst app = sokol.app;\nconst sg = sokol.gfx;\nconst slog = sokol.log;\nconst glue = sokol.glue;\nconst imgui = sokol.imgui;\nconst util = @import(\"../util.zig\");\nconst math = util.math;\nconst mat4 = math.Mat4;\nconst types = @import(\"../types.zig\");\nconst RenderPassIds = types.RendererTypes.RenderPassIds;\nconst Entity = types.Entity;\nconst State = @import(\"../state.zig\");\nconst EditorState = @import(\"../editor.zig\").EditorState;\nconst log = std.log.scoped(.entity_editor);\n\nconst predefined_colors = [_]ig.ImVec4_t{\n    .{ .x = 1.0, .y = 0.0, .z = 0.0, .w = 1.0 }, // red\n    .{ .x = 0.0, .y = 1.0, .z = 0.0, .w = 1.0 }, // green\n    .{ .x = 0.0, .y = 0.0, .z = 1.0, .w = 1.0 }, // blue\n    .{ .x = 1.0, .y = 1.0, .z = 0.0, .w = 1.0 }, // yellow\n    .{ .x = 1.0, .y = 1.0, .z = 1.0, .w = 1.0 }, // white\n    .{ .x = 0.0, .y = 0.0, .z = 0.0, .w = 1.0 }, // black\n};\n\npub fn drawEntityEditor(editor_state: *EditorState) !void {\n    if (ig.igButton(\"Add entity\")) {\n        if (editor_state.state.loaded_scene) |*scene| {\n            const new_entity: Entity = .{};\n            try scene.entities.append(editor_state.allocator, new_entity);\n            editor_state.state.selected_entity = scene.entities.len - 1;\n            try editor_state.state.renderer.render_passes.items[@intFromEnum(RenderPassIds.ENTITY_1)].appendSpriteToBatch(new_entity.toSpriteRenderable());\n            log.info(\"entity count: {}\", .{scene.entities.len});\n        }\n    }\n    if (editor_state.state.selected_entity) |s| {\n        if (editor_state.state.selected_tile_click) {\n            const entity = editor_state.state.loaded_scene.?.entities.get(s);\n            const selected = try std.fmt.allocPrint(\n                editor_state.allocator,\n                \"ENTID: {d}\\nSprite id: {d}\\nPos: {}, {}\",\n                .{\n                    s,\n                    entity.sprite_id,\n                    entity.pos.x,\n                    entity.pos.y,\n                },\n            );\n            defer editor_state.allocator.free(selected);\n            ig.igText(selected.ptr);\n        }\n    }\n}\n\npub fn drawTileEditor(editor_state: *EditorState) !void {\n    if (editor_state.state.selected_tile) |s| {\n        if (editor_state.state.selected_tile_click) {\n            var tile = editor_state.state.loaded_scene.?.tiles.get(s);\n            const selected = try std.fmt.allocPrint(\n                editor_state.allocator,\n                \"ENTID: {d}\\nSprite id: {d}\\nPos: {}, {}, {}\",\n                .{\n                    s,\n                    tile.sprite_renderable.sprite_id,\n                    tile.sprite_renderable.pos.x,\n                    tile.sprite_renderable.pos.y,\n                    tile.sprite_renderable.pos.z,\n                },\n            );\n            defer editor_state.allocator.free(selected);\n            ig.igText(selected.ptr);\n\n            var color_array = tile.sprite_renderable.color.toArray();\n            _ = ig.igColorPicker4(\"Color\", &color_array, ig.ImGuiColorEditFlags_None, null);\n            _ = ig.igText(\"Preset Colors:\");\n            ig.igNewLine();\n            for (predefined_colors, 0..) |preset, i| {\n                ig.igSameLine();\n                const str = try std.fmt.allocPrintZ(editor_state.allocator, \"##c{}\", .{i});\n                defer editor_state.allocator.free(str);\n                if (ig.igColorButton(\n                    str.ptr,\n                    preset,\n                    ig.ImGuiColorEditFlags_None,\n                )) {\n                    color_array = [4]f32{ preset.x, preset.y, preset.z, preset.w };\n                }\n            }\n            tile.sprite_renderable.color = math.Vec4.fromArray(color_array);\n            _ = ig.igInputFloat(\"Sprite ID: \", &tile.sprite_renderable.sprite_id);\n\n            _ = ig.igCheckbox(\"Spawner\", &tile.spawner);\n            _ = ig.igCheckbox(\"Traversable\", &tile.traversable);\n            editor_state.state.loaded_scene.?.tiles.set(s, tile);\n\n            if (editor_state.state.renderer.render_passes.items[@intFromEnum(editor_state.selected_layer)].batch.items.len > s) {\n                try editor_state.state.renderer.render_passes.items[@intFromEnum(editor_state.selected_layer)].updateSpriteRenderables(s, tile.sprite_renderable);\n            }\n        }\n    }\n}\n"
                        "entity_editor.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/editor/entity_editor.zig"
                        nil nil)
                       ("console.zig"
                        "const std = @import(\"std\");\nconst ig = @import(\"cimgui\");\nconst log = std.log.scoped(.console);\n\nvar console_buf: [8192]u8 = undefined;\n\n// @todo cli tools?\npub const vtable = struct {};\n\nconst Console = @This();\nhistory_buf: std.ArrayList([]const u8),\nhistory_file: std.fs.File,\nopen: bool,\n\npub fn init(\n    self: *Console,\n    allocator: std.mem.Allocator,\n) !void {\n    self.history_buf = std.ArrayList([]const u8).init(allocator);\n    var dir = try std.fs.cwd().openDir(\"assets\", .{});\n    self.history_file = try dir.openFile(\"logs\", .{ .mode = .read_write });\n    self.open = false;\n}\n\npub fn console(\n    self: *Console,\n    allocator: std.mem.Allocator,\n) !void {\n    _ = ig.igBegin(\"Drawer\", 0, ig.ImGuiWindowFlags_None);\n    if (ig.igIsWindowFocused(ig.ImGuiFocusedFlags_RootAndChildWindows)) {\n        ig.igSetKeyboardFocusHere();\n    }\n    for (self.history_buf.items) |entry| {\n        ig.igText(entry.ptr);\n    }\n    ig.igSameLine();\n    if (ig.igInputText(\" \", &console_buf, console_buf.len, ig.ImGuiInputTextFlags_EnterReturnsTrue | ig.ImGuiInputTextFlags_AllowTabInput)) {\n        const console_input: []const u8 = std.mem.span(@as([*c]u8, @ptrCast(console_buf[0..].ptr)));\n        try self.history_buf.append(try allocator.dupe(u8, console_input));\n        log.info(\"{}\", .{self.history_buf.items.len});\n        console_buf = std.mem.zeroes([8192]u8);\n        //if (self.history_buf.items.len >= 15) {\n        //    const record = self.history_buf.orderedRemove(0);\n        //    _ = try self.history_file.writeAll(record);\n        //    _ = try self.history_file.write(\"\\n\");\n        //}\n    }\n    _ = ig.igButton(\"save logs\");\n    ig.igEnd();\n}\n"
                        "console.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/editor/console.zig"
                        nil nil)))


;;; Snippet definitions:
;;;
(yas-define-snippets 'src
                     '(("RenderText.zig" "" "RenderText.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/renderer/RenderText.zig"
                        nil nil)
                       ("RenderQuad.zig"
                        "// The idea is these are quads that do not have other\n// features, ie textures.\n\nconst std = @import(\"std\");\nconst log = std.log.scoped(.render_quad);\nconst sokol = @import(\"sokol\");\nconst glue = sokol.glue;\nconst util = @import(\"../util.zig\");\nconst math = util.math;\nconst shd = @import(\"../shaders/quad.glsl.zig\");\nconst sg = sokol.gfx;\n\nconst Vao = &[_][]f32{\n    [_]f32{},\n    [_]f32{},\n    [_]f32{},\n    [_]f32{},\n};\n\nconst Self = @This();\npass_action: sg.PassAction = .{},\nbindings: sg.Bindings = .{},\npipeline: sg.Pipeline = .{},\n\npub fn drawQuad2dSpace(pos: math.Vec2, color: math.Vec3, vs_params: shd.VsParams) void {\n    var self = Self{};\n\n    const verts = [_]f32{\n        0 + pos.x, 1 + pos.y, 0.0, color.x, color.y, color.z,\n        1 + pos.x, 1 + pos.y, 0.0, color.x, color.y, color.z,\n        1 + pos.x, 0 + pos.y, 0.0, color.x, color.y, color.z,\n        0 + pos.x, 0 + pos.y, 0.0, color.x, color.y, color.z,\n    };\n\n    const indices = [_]u16{\n        0, 1, 2,\n        0, 2, 3,\n    };\n    self.bindings.vertex_buffers[0] = sg.makeBuffer(.{\n        .type = .VERTEXBUFFER,\n        .data = sg.asRange(&verts),\n    });\n    defer sg.destroyBuffer(self.bindings.vertex_buffers[0]);\n    self.bindings.index_buffer = sg.makeBuffer(.{\n        .type = .INDEXBUFFER,\n        .data = sg.asRange(&indices),\n    });\n    defer sg.destroyBuffer(self.bindings.index_buffer);\n\n    const quad_shd = sg.makeShader(shd.quadShaderDesc(sg.queryBackend()));\n    defer sg.destroyShader(quad_shd);\n\n    self.pipeline = sg.makePipeline(.{\n        .shader = quad_shd,\n        .layout = init: {\n            var l = sg.VertexLayoutState{};\n            l.attrs[shd.ATTR_quad_position] = .{ .format = .FLOAT3, .buffer_index = 0 };\n            l.attrs[shd.ATTR_quad_color] = .{ .format = .FLOAT3, .buffer_index = 0 };\n            break :init l;\n        },\n        .index_type = .UINT16,\n        .cull_mode = .BACK,\n        .sample_count = 1,\n    });\n    defer sg.destroyPipeline(self.pipeline);\n\n    self.pass_action.colors[0] = .{\n        .load_action = .CLEAR,\n        .clear_value = .{ .r = 0, .g = 0, .b = 0, .a = 1 },\n    };\n\n    sg.beginPass(.{ .action = self.pass_action, .swapchain = glue.swapchain() });\n    sg.applyPipeline(self.pipeline);\n    sg.applyBindings(self.bindings);\n    sg.applyUniforms(shd.UB_vs_params, sg.asRange(&vs_params));\n    sg.draw(0, 6, 1);\n    sg.endPass();\n}\n"
                        "RenderQuad.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/renderer/RenderQuad.zig"
                        nil nil)
                       ("RenderPass.zig"
                        "const std = @import(\"std\");\nconst sokol = @import(\"sokol\");\nconst util = @import(\"../util.zig\");\nconst math = util.math;\nconst shd = @import(\"../shaders/basic.glsl.zig\");\nconst cim = @cImport({\n    @cInclude(\"stb_image.h\");\n});\nconst sg = sokol.gfx;\nconst types = @import(\"../types.zig\");\nconst Scene = types.Scene;\nconst Entity = types.Entity;\nconst RendererTypes = types.RendererTypes;\nconst SpriteRenderable = RendererTypes.SpriteRenderable;\nconst log = std.log.scoped(.render_pass);\n\nfn xorshift32() u32 {\n    const static = struct {\n        var x: u32 = 0x12345678;\n    };\n    var x = static.x;\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    static.x = x;\n    return x;\n}\n\nfn rand(min_val: f32, max_val: f32) f32 {\n    return (@as(f32, @floatFromInt(xorshift32() & 0xFFFF)) / 0x10000) * (max_val - min_val) + min_val;\n}\n\nconst Self = @This();\nid: RendererTypes.RenderPassIds,\npass_action: sg.PassAction,\nbindings: sg.Bindings,\nimage: sg.Image,\npipeline: sg.Pipeline,\nbatch: std.ArrayList(SpriteRenderable),\ncur_num_of_sprite: u32 = 0,\nmax_sprites_per_batch: u32,\nsprite_size: [2]f32,\natlas_size: [2]f32,\npath: []const u8,\n\npub fn init(\n    self: *Self,\n    id: RendererTypes.RenderPassIds,\n    spritesheet_path: []const u8,\n    sprite_size: [2]f32,\n    atlas_size: [2]f32,\n    allocator: std.mem.Allocator,\n) !void {\n    log.info(\"Render pass initial: {s}\", .{spritesheet_path});\n    self.id = id;\n    self.cur_num_of_sprite = 0;\n    self.max_sprites_per_batch = 10000;\n    self.batch = try std.ArrayList(SpriteRenderable).initCapacity(allocator, 100);\n    self.sprite_size = sprite_size;\n    self.atlas_size = atlas_size;\n    self.path = spritesheet_path;\n\n    const verts = [_]f32{\n        0, 1, 0.0, 0.0, 1.0,\n        1, 1, 0.0, 1.0, 1.0,\n        1, 0, 0.0, 1.0, 0.0,\n        0, 0, 0.0, 0.0, 0.0,\n    };\n\n    const indices = [_]u16{\n        0, 1, 2,\n        0, 2, 3,\n    };\n    self.bindings = .{};\n    self.bindings.images[shd.IMG_tex2d] = sg.allocImage();\n    self.bindings.samplers[shd.SMP_smp] = sg.makeSampler(.{\n        .min_filter = .NEAREST,\n        .mag_filter = .NEAREST,\n    });\n    self.bindings.vertex_buffers[0] = sg.makeBuffer(.{\n        .type = .VERTEXBUFFER,\n        .data = sg.asRange(&verts),\n    });\n    self.bindings.vertex_buffers[1] = sg.makeBuffer(.{\n        .usage = .STREAM,\n        .size = self.max_sprites_per_batch * @bitSizeOf(SpriteRenderable),\n    });\n    self.bindings.index_buffer = sg.makeBuffer(.{\n        .type = .INDEXBUFFER,\n        .data = sg.asRange(&indices),\n    });\n\n    self.pipeline = sg.makePipeline(.{\n        .shader = sg.makeShader(shd.basicShaderDesc(sg.queryBackend())),\n        .layout = init: {\n            var l = sg.VertexLayoutState{};\n            l.buffers[1].step_func = .PER_INSTANCE;\n            l.attrs[shd.ATTR_basic_position] = .{ .format = .FLOAT3, .buffer_index = 0 };\n            l.attrs[shd.ATTR_basic_uv_coords] = .{ .format = .FLOAT2, .buffer_index = 0 };\n            l.attrs[shd.ATTR_basic_pos] = .{ .format = .FLOAT4, .buffer_index = 1 };\n            l.attrs[shd.ATTR_basic_color] = .{ .format = .FLOAT4, .buffer_index = 1 };\n            break :init l;\n        },\n        .index_type = .UINT16,\n        .cull_mode = .BACK,\n        .sample_count = 1,\n        .depth = .{\n            .pixel_format = .DEPTH_STENCIL,\n            .compare = .LESS_EQUAL,\n            .write_enabled = true,\n        },\n        .colors = init: {\n            var c: [4]sg.ColorTargetState = @splat(.{});\n            c[0].pixel_format = .RGBA8;\n            c[0].blend = .{\n                .enabled = true,\n                .src_factor_rgb = .SRC_ALPHA,\n                .dst_factor_rgb = .ONE_MINUS_SRC_ALPHA,\n                .src_factor_alpha = .ONE,\n                .dst_factor_alpha = .ONE_MINUS_SRC_ALPHA,\n            };\n            break :init c;\n        },\n    });\n    var x: c_int = 0;\n    var y: c_int = 0;\n    var chan: c_int = 0;\n\n    cim.stbi_set_flip_vertically_on_load(1);\n    const data = cim.stbi_load(spritesheet_path.ptr, &x, &y, &chan, 4);\n\n    sg.initImage(self.bindings.images[shd.IMG_tex2d], .{\n        .width = x,\n        .height = y,\n        .pixel_format = .RGBA8,\n        .data = init: {\n            var idata = sg.ImageData{};\n            idata.subimage[0][0] = .{\n                .ptr = data,\n                .size = @as(usize, @intCast(x * y * chan)),\n            };\n            break :init idata;\n        },\n    });\n\n    self.pass_action.colors[0] = .{\n        .load_action = .CLEAR,\n        .clear_value = .{ .r = 0, .g = 0, .b = 0, .a = 1 },\n    };\n}\n\npub fn appendSpriteSliceToBatch(\n    self: *Self,\n    sprite: []SpriteRenderable,\n) !void {\n    try self.batch.appendSliceAssumeCapacity(sprite);\n    self.cur_num_of_sprite = sprite.len;\n}\npub fn appendSpriteToBatch(\n    self: *Self,\n    sprite: SpriteRenderable,\n) !void {\n    try self.batch.append(sprite);\n    self.cur_num_of_sprite += 1;\n}\n\npub fn updateSpriteRenderables(\n    self: *Self,\n    index: usize,\n    sprite: SpriteRenderable,\n) !void {\n    self.batch.items[index] = sprite;\n}\n\npub fn updateBuffers(self: *Self) void {\n    sg.updateBuffer(\n        self.bindings.vertex_buffers[1],\n        sg.asRange(self.batch.items[0..self.cur_num_of_sprite]),\n    );\n}\n\npub fn render(\n    self: *Self,\n    vs_params: shd.VsParams,\n) void {\n    const fs_params = shd.FsParams{\n        .atlas_size = self.atlas_size,\n        .sprite_size = self.sprite_size,\n    };\n    sg.applyPipeline(self.pipeline);\n    sg.applyBindings(self.bindings);\n    sg.applyUniforms(shd.UB_vs_params, sg.asRange(&vs_params));\n    sg.applyUniforms(shd.UB_fs_params, sg.asRange(&fs_params));\n    sg.draw(0, 6, self.cur_num_of_sprite);\n}\n"
                        "RenderPass.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/renderer/RenderPass.zig"
                        nil nil)
                       ("RenderConfigs.zig"
                        "const util = @import(\"../util.zig\");\nconst math = util.math;\nconst types = @import(\"../types.zig\");\nconst Scene = types.Scene;\nconst Entity = types.Entity;\nconst RendererTypes = types.RendererTypes;\nconst SpriteRenderable = RendererTypes.SpriteRenderable;\n\npub const RenderPassConfig = struct {\n    id: RendererTypes.RenderPassIds,\n    path: []const u8,\n    atlas_size: [2]f32,\n    sprite_size: [2]f32,\n};\n\n// @incorrect_rendering Likely due to spritesheet dimensions being\n// incorrect\npub var Defaults = &[_]RenderPassConfig{\n    .{\n        .id = .TILES_1,\n        .path = \"assets/tiles_1.png\",\n        .sprite_size = .{ 16, 16 },\n        .atlas_size = .{ 256, 256 },\n    },\n    .{\n        .id = .TILES_2,\n        .path = \"assets/tiles_2.png\",\n        .sprite_size = .{ 16, 16 },\n        .atlas_size = .{ 256, 256 },\n    },\n    .{\n        .id = .ENTITY_1,\n        .path = \"assets/entity_1.png\",\n        .sprite_size = .{ 16, 16 },\n        .atlas_size = .{ 256, 256 },\n    },\n    .{\n        .id = .UI_1,\n        .path = \"assets/ui_1.png\",\n        .sprite_size = .{ 16, 16 },\n        .atlas_size = .{ 256, 256 },\n    },\n};\n"
                        "RenderConfigs.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/renderer/RenderConfigs.zig"
                        nil nil)))


;;; Snippet definitions:
;;;
(yas-define-snippets 'src
                     '(("lua.zig"
                        "//const std = @import(\"std\");\n//const c = @import(\"c.zig\");\n//const types = @import(\"../types.zig\");\n//const Entity = types.Entity;\n//\n//var e: Entity = .{};\n//\n///// Interfaces for LUA types.\n/////\n///// Entity API\n///// Algorithms API\n//const Self = @This();\n//state: ?*c.lua_State,\n//\n//export fn getId(state: ?*c.lua_State) c_int {\n//    // Get the entity from the upvalue\n//    const entity_ptr = c.lua_touserdata(state, c.lua_upvalueindex(1));\n//    const entity: *Entity = @ptrCast(@alignCast(entity_ptr));\n//    c.lua_pushinteger(state, @intCast(entity.id));\n//    return 1;\n//}\n//\n//export fn testIndex(state: ?*c.lua_State) void {\n//    // Create a table that will be our API\n//    c.lua_newtable(state);\n//\n//    // Setup the getId function with entity as upvalue\n//    c.lua_pushlightuserdata(state, &e);\n//    c.lua_pushcclosure(state, getId, 1);\n//    c.lua_setfield(state, -2, \"getId\");\n//\n//    // Set the table as a global named \"entity\"\n//    c.lua_setglobal(state, \"entity\");\n//}\n//\n//pub fn luaTest() !void {\n//    const lua_state = c.luaL_newstate();\n//    if (lua_state == null) {\n//        return error.LuaInitFailed;\n//    }\n//\n//    // Open standard Lua libraries (math, string, etc.)\n//    c.luaL_openlibs(lua_state);\n//    testIndex(lua_state);\n//\n//    var buf: [4096]u8 = undefined;\n//    var file = try std.fs.cwd().openFile(\"src/scripts/test.lua\", .{});\n//    const length = try file.readAll(&buf);\n//    file.close();\n//\n//    buf[length] = 0;\n//\n//    const status = c.luaL_loadstring(lua_state, &buf);\n//    if (status != c.LUA_OK) {\n//        std.log.err(\"loadstring error: {}\", .{status});\n//        return error.LuaLoadFailed;\n//    }\n//\n//    const call_status = c.lua_pcallk(lua_state, 0, 0, 0, 0, null);\n//    if (call_status != c.LUA_OK) {\n//        std.log.err(\"run err loadstring error: {}\", .{status});\n//        return error.LuaCallFailed;\n//    }\n//    c.lua_close(lua_state);\n//}\n//\n//pub fn loadScript(self: *Self, script: []const u8) !void {\n//    const status = c.luaL_loadstring(self.state, script.ptr);\n//    if (status != c.LUA_OK) {\n//        std.log.err(\"loadstring error: {}\", .{status});\n//        return error.LuaLoadFailed;\n//    }\n//}\n//\n//pub fn runScripts(self: *Self) void {\n//    const call_status = c.lua_pcallk(self.state, 0, 0, 0, 0, null);\n//    if (call_status != c.LUA_OK) {\n//        std.log.err(\"run err loadstring error: {}\", .{call_status});\n//        return error.LuaCallFailed;\n//    }\n//}\n//\n//pub fn deinit(self: *Self) void {\n//    _ = self;\n//    c.lua_close();\n//}\n"
                        "lua.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/scripting/lua.zig"
                        nil nil)))


;;; Snippet definitions:
;;;
(yas-define-snippets 'src
                     '(("test.lua"
                        "local function even_fibo()\n  -- create Fibonacci sequence\n  local fib = {1, 2}  -- starting with 1, 2\n  for i=3, 10 do\n    fib[i] = fib[i-2] + fib[i-1]\n  end\n  -- calculate sum of even numbers\n  local fib_sum = 0\n  for _, v in ipairs(fib) do\n    if v%2 == 0 then\n      fib_sum = fib_sum + v\n    end\n  end\n  return fib_sum\nend\n\nlocal fib = even_fibo()\nprint(\"This is the fibinacci number called from lua\", fib)\n\nprint(\"Entity id\", entity.getId())\n"
                        "test.lua" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/scripts/test.lua"
                        nil nil)))


;;; Snippet definitions:
;;;
(yas-define-snippets 'src
                     '(("quad.glsl.zig"
                        "const sg = @import(\"sokol\").gfx;\nconst std = @import(\"std\");\nconst m = @import(\"../util/math.zig\");\n//\n//    #version:1# (machine generated, don't edit!)\n//\n//    Generated by sokol-shdc (https://github.com/floooh/sokol-tools)\n//\n//    Cmdline:\n//        sokol-shdc --input src/shaders/quad.glsl --output src/shaders/quad.glsl.zig --slang glsl430:metal_macos --format sokol_zig\n//\n//    Overview:\n//    =========\n//    Shader program: 'quad':\n//        Get shader desc: shd.quadShaderDesc(sg.queryBackend());\n//        Vertex Shader: vs\n//        Fragment Shader: fs\n//        Attributes:\n//            ATTR_quad_position => 0\n//            ATTR_quad_color => 1\n//    Bindings:\n//        Uniform block 'vs_params':\n//            Zig struct: VsParams\n//            Bind slot: UB_vs_params => 0\n//\npub const ATTR_quad_position = 0;\npub const ATTR_quad_color = 1;\npub const UB_vs_params = 0;\npub const VsParams = extern struct {\n    mvp: m.Mat4 align(16),\n};\n//\n//    #version 430\n//\n//    uniform vec4 vs_params[4];\n//    layout(location = 0) in vec3 position;\n//    layout(location = 1) in vec3 color;\n//    layout(location = 0) out vec3 outcolor;\n//\n//    void main()\n//    {\n//        gl_Position = mat4(vs_params[0], vs_params[1], vs_params[2], vs_params[3]) * vec4(position * 16.0, 1.0);\n//    }\n//\n//\nconst vs_source_glsl430 = [284]u8 {\n    0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x34,0x33,0x30,0x0a,0x0a,0x75,0x6e,\n    0x69,0x66,0x6f,0x72,0x6d,0x20,0x76,0x65,0x63,0x34,0x20,0x76,0x73,0x5f,0x70,0x61,\n    0x72,0x61,0x6d,0x73,0x5b,0x34,0x5d,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,\n    0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x30,0x29,0x20,0x69,0x6e,\n    0x20,0x76,0x65,0x63,0x33,0x20,0x70,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x3b,0x0a,\n    0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,\n    0x3d,0x20,0x31,0x29,0x20,0x69,0x6e,0x20,0x76,0x65,0x63,0x33,0x20,0x63,0x6f,0x6c,\n    0x6f,0x72,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,\n    0x69,0x6f,0x6e,0x20,0x3d,0x20,0x30,0x29,0x20,0x6f,0x75,0x74,0x20,0x76,0x65,0x63,\n    0x33,0x20,0x6f,0x75,0x74,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x0a,0x76,0x6f,0x69,\n    0x64,0x20,0x6d,0x61,0x69,0x6e,0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x67,\n    0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x6d,0x61,0x74,\n    0x34,0x28,0x76,0x73,0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x5b,0x30,0x5d,0x2c,0x20,\n    0x76,0x73,0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x5b,0x31,0x5d,0x2c,0x20,0x76,0x73,\n    0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x5b,0x32,0x5d,0x2c,0x20,0x76,0x73,0x5f,0x70,\n    0x61,0x72,0x61,0x6d,0x73,0x5b,0x33,0x5d,0x29,0x20,0x2a,0x20,0x76,0x65,0x63,0x34,\n    0x28,0x70,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x2a,0x20,0x31,0x36,0x2e,0x30,\n    0x2c,0x20,0x31,0x2e,0x30,0x29,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,\n};\n//\n//    #version 430\n//\n//    layout(location = 0) out vec4 frag_color;\n//    layout(location = 0) in vec3 outcolor;\n//\n//    void main()\n//    {\n//        frag_color = vec4(outcolor, 1.0);\n//    }\n//\n//\nconst fs_source_glsl430 = [152]u8 {\n    0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x34,0x33,0x30,0x0a,0x0a,0x6c,0x61,\n    0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,\n    0x30,0x29,0x20,0x6f,0x75,0x74,0x20,0x76,0x65,0x63,0x34,0x20,0x66,0x72,0x61,0x67,\n    0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,\n    0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x30,0x29,0x20,0x69,0x6e,0x20,\n    0x76,0x65,0x63,0x33,0x20,0x6f,0x75,0x74,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x0a,\n    0x76,0x6f,0x69,0x64,0x20,0x6d,0x61,0x69,0x6e,0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,\n    0x20,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x76,\n    0x65,0x63,0x34,0x28,0x6f,0x75,0x74,0x63,0x6f,0x6c,0x6f,0x72,0x2c,0x20,0x31,0x2e,\n    0x30,0x29,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,\n};\n//\n//    #include <metal_stdlib>\n//    #include <simd/simd.h>\n//\n//    using namespace metal;\n//\n//    struct vs_params\n//    {\n//        float4x4 mvp;\n//    };\n//\n//    struct main0_out\n//    {\n//        float3 outcolor [[user(locn0)]];\n//        float4 gl_Position [[position]];\n//    };\n//\n//    struct main0_in\n//    {\n//        float3 position [[attribute(0)]];\n//    };\n//\n//    vertex main0_out main0(main0_in in [[stage_in]], constant vs_params& _19 [[buffer(0)]])\n//    {\n//        main0_out out = {};\n//        out.gl_Position = _19.mvp * float4(in.position * 16.0, 1.0);\n//        return out;\n//    }\n//\n//\nconst vs_source_metal_macos = [469]u8 {\n    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,\n    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,\n    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,\n    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,\n    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x76,\n    0x73,0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,\n    0x6c,0x6f,0x61,0x74,0x34,0x78,0x34,0x20,0x6d,0x76,0x70,0x3b,0x0a,0x7d,0x3b,0x0a,\n    0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,\n    0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x33,0x20,0x6f,\n    0x75,0x74,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,\n    0x6f,0x63,0x6e,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,\n    0x61,0x74,0x34,0x20,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,\n    0x5b,0x5b,0x70,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,\n    0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,\n    0x6e,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x33,0x20,0x70,\n    0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,\n    0x75,0x74,0x65,0x28,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x76,0x65,\n    0x72,0x74,0x65,0x78,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,\n    0x61,0x69,0x6e,0x30,0x28,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,\n    0x20,0x5b,0x5b,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x63,\n    0x6f,0x6e,0x73,0x74,0x61,0x6e,0x74,0x20,0x76,0x73,0x5f,0x70,0x61,0x72,0x61,0x6d,\n    0x73,0x26,0x20,0x5f,0x31,0x39,0x20,0x5b,0x5b,0x62,0x75,0x66,0x66,0x65,0x72,0x28,\n    0x30,0x29,0x5d,0x5d,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,0x6e,\n    0x30,0x5f,0x6f,0x75,0x74,0x20,0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,0x0a,\n    0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x67,0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,\n    0x69,0x6f,0x6e,0x20,0x3d,0x20,0x5f,0x31,0x39,0x2e,0x6d,0x76,0x70,0x20,0x2a,0x20,\n    0x66,0x6c,0x6f,0x61,0x74,0x34,0x28,0x69,0x6e,0x2e,0x70,0x6f,0x73,0x69,0x74,0x69,\n    0x6f,0x6e,0x20,0x2a,0x20,0x31,0x36,0x2e,0x30,0x2c,0x20,0x31,0x2e,0x30,0x29,0x3b,\n    0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,0x74,0x3b,\n    0x0a,0x7d,0x0a,0x0a,0x00,\n};\n//\n//    #include <metal_stdlib>\n//    #include <simd/simd.h>\n//\n//    using namespace metal;\n//\n//    struct main0_out\n//    {\n//        float4 frag_color [[color(0)]];\n//    };\n//\n//    struct main0_in\n//    {\n//        float3 outcolor [[user(locn0)]];\n//    };\n//\n//    fragment main0_out main0(main0_in in [[stage_in]])\n//    {\n//        main0_out out = {};\n//        out.frag_color = float4(in.outcolor, 1.0);\n//        return out;\n//    }\n//\n//\nconst fs_source_metal_macos = [334]u8 {\n    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,\n    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,\n    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,\n    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,\n    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,\n    0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,\n    0x6c,0x6f,0x61,0x74,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,\n    0x20,0x5b,0x5b,0x63,0x6f,0x6c,0x6f,0x72,0x28,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,\n    0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,\n    0x69,0x6e,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x33,0x20,\n    0x6f,0x75,0x74,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,\n    0x6c,0x6f,0x63,0x6e,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x66,0x72,\n    0x61,0x67,0x6d,0x65,0x6e,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,\n    0x20,0x6d,0x61,0x69,0x6e,0x30,0x28,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x20,\n    0x69,0x6e,0x20,0x5b,0x5b,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,0x6e,0x5d,0x5d,0x29,\n    0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,\n    0x20,0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,\n    0x75,0x74,0x2e,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,\n    0x66,0x6c,0x6f,0x61,0x74,0x34,0x28,0x69,0x6e,0x2e,0x6f,0x75,0x74,0x63,0x6f,0x6c,\n    0x6f,0x72,0x2c,0x20,0x31,0x2e,0x30,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,\n    0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,0x74,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,\n};\npub fn quadShaderDesc(backend: sg.Backend) sg.ShaderDesc {\n    var desc: sg.ShaderDesc = .{};\n    desc.label = \"quad_shader\";\n    switch (backend) {\n        .GLCORE => {\n            desc.vertex_func.source = &vs_source_glsl430;\n            desc.vertex_func.entry = \"main\";\n            desc.fragment_func.source = &fs_source_glsl430;\n            desc.fragment_func.entry = \"main\";\n            desc.attrs[0].glsl_name = \"position\";\n            desc.attrs[1].glsl_name = \"color\";\n            desc.uniform_blocks[0].stage = .VERTEX;\n            desc.uniform_blocks[0].layout = .STD140;\n            desc.uniform_blocks[0].size = 64;\n            desc.uniform_blocks[0].glsl_uniforms[0].type = .FLOAT4;\n            desc.uniform_blocks[0].glsl_uniforms[0].array_count = 4;\n            desc.uniform_blocks[0].glsl_uniforms[0].glsl_name = \"vs_params\";\n        },\n        .METAL_MACOS => {\n            desc.vertex_func.source = &vs_source_metal_macos;\n            desc.vertex_func.entry = \"main0\";\n            desc.fragment_func.source = &fs_source_metal_macos;\n            desc.fragment_func.entry = \"main0\";\n            desc.uniform_blocks[0].stage = .VERTEX;\n            desc.uniform_blocks[0].layout = .STD140;\n            desc.uniform_blocks[0].size = 64;\n            desc.uniform_blocks[0].msl_buffer_n = 0;\n        },\n        else => {},\n    }\n    return desc;\n}\n"
                        "quad.glsl.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/shaders/quad.glsl.zig"
                        nil nil)
                       ("quad.glsl"
                        "@header const m = @import(\"../util/math.zig\")\n@ctype mat4 m.Mat4\n\n@vs vs\nlayout(binding=0) uniform vs_params {\n    mat4 mvp;\n};\n\nin vec3 position;\nin vec3 color;\n\nout vec3 outcolor;\n\nvoid main() {\n    gl_Position = mvp * vec4((position * 16), 1.0);\n}\n@end\n\n@fs fs\nin vec3 outcolor;\n\nout vec4 frag_color;\n\nvoid main() {\n    frag_color = vec4(outcolor, 1.0);\n}\n@end\n\n@program quad vs fs\n"
                        "quad.glsl" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/shaders/quad.glsl"
                        nil nil)
                       ("basic.glsl.zig"
                        "const sg = @import(\"sokol\").gfx;\nconst std = @import(\"std\");\nconst m = @import(\"../util/math.zig\");\n//\n//    #version:1# (machine generated, don't edit!)\n//\n//    Generated by sokol-shdc (https://github.com/floooh/sokol-tools)\n//\n//    Cmdline:\n//        sokol-shdc --input src/shaders/basic.glsl --output src/shaders/basic.glsl.zig --slang glsl430:metal_macos --format sokol_zig\n//\n//    Overview:\n//    =========\n//    Shader program: 'basic':\n//        Get shader desc: shd.basicShaderDesc(sg.queryBackend());\n//        Vertex Shader: vs\n//        Fragment Shader: fs\n//        Attributes:\n//            ATTR_basic_position => 0\n//            ATTR_basic_uv_coords => 1\n//            ATTR_basic_pos => 2\n//            ATTR_basic_color => 3\n//    Bindings:\n//        Uniform block 'vs_params':\n//            Zig struct: VsParams\n//            Bind slot: UB_vs_params => 0\n//        Uniform block 'fs_params':\n//            Zig struct: FsParams\n//            Bind slot: UB_fs_params => 1\n//        Image 'tex2d':\n//            Image type: ._2D\n//            Sample type: .FLOAT\n//            Multisampled: false\n//            Bind slot: IMG_tex2d => 0\n//        Sampler 'smp':\n//            Type: .FILTERING\n//            Bind slot: SMP_smp => 0\n//\npub const ATTR_basic_position = 0;\npub const ATTR_basic_uv_coords = 1;\npub const ATTR_basic_pos = 2;\npub const ATTR_basic_color = 3;\npub const UB_vs_params = 0;\npub const UB_fs_params = 1;\npub const IMG_tex2d = 0;\npub const SMP_smp = 0;\npub const VsParams = extern struct {\n    mvp: m.Mat4 align(16),\n};\npub const FsParams = extern struct {\n    atlas_size: [2]f32 align(16),\n    sprite_size: [2]f32 align(1),\n};\n//\n//    #version 430\n//\n//    uniform vec4 vs_params[4];\n//    layout(location = 0) in vec3 position;\n//    layout(location = 2) in vec4 pos;\n//    layout(location = 1) out float id;\n//    layout(location = 0) out vec2 uv;\n//    layout(location = 1) in vec2 uv_coords;\n//    layout(location = 2) out vec4 ocolor;\n//    layout(location = 3) in vec4 color;\n//\n//    void main()\n//    {\n//        gl_Position = mat4(vs_params[0], vs_params[1], vs_params[2], vs_params[3]) * vec4((position * 16.0) + pos.xyz, 1.0);\n//        id = pos.w;\n//        uv = uv_coords;\n//        ocolor = color;\n//    }\n//\n//\nconst vs_source_glsl430 = [493]u8 {\n    0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x34,0x33,0x30,0x0a,0x0a,0x75,0x6e,\n    0x69,0x66,0x6f,0x72,0x6d,0x20,0x76,0x65,0x63,0x34,0x20,0x76,0x73,0x5f,0x70,0x61,\n    0x72,0x61,0x6d,0x73,0x5b,0x34,0x5d,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,\n    0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x30,0x29,0x20,0x69,0x6e,\n    0x20,0x76,0x65,0x63,0x33,0x20,0x70,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x3b,0x0a,\n    0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,\n    0x3d,0x20,0x32,0x29,0x20,0x69,0x6e,0x20,0x76,0x65,0x63,0x34,0x20,0x70,0x6f,0x73,\n    0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,\n    0x6e,0x20,0x3d,0x20,0x31,0x29,0x20,0x6f,0x75,0x74,0x20,0x66,0x6c,0x6f,0x61,0x74,\n    0x20,0x69,0x64,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,\n    0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x30,0x29,0x20,0x6f,0x75,0x74,0x20,0x76,0x65,\n    0x63,0x32,0x20,0x75,0x76,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,\n    0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x31,0x29,0x20,0x69,0x6e,0x20,0x76,\n    0x65,0x63,0x32,0x20,0x75,0x76,0x5f,0x63,0x6f,0x6f,0x72,0x64,0x73,0x3b,0x0a,0x6c,\n    0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,\n    0x20,0x32,0x29,0x20,0x6f,0x75,0x74,0x20,0x76,0x65,0x63,0x34,0x20,0x6f,0x63,0x6f,\n    0x6c,0x6f,0x72,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,\n    0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x33,0x29,0x20,0x69,0x6e,0x20,0x76,0x65,0x63,\n    0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x0a,0x76,0x6f,0x69,0x64,0x20,0x6d,\n    0x61,0x69,0x6e,0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x67,0x6c,0x5f,0x50,\n    0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x6d,0x61,0x74,0x34,0x28,0x76,\n    0x73,0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x5b,0x30,0x5d,0x2c,0x20,0x76,0x73,0x5f,\n    0x70,0x61,0x72,0x61,0x6d,0x73,0x5b,0x31,0x5d,0x2c,0x20,0x76,0x73,0x5f,0x70,0x61,\n    0x72,0x61,0x6d,0x73,0x5b,0x32,0x5d,0x2c,0x20,0x76,0x73,0x5f,0x70,0x61,0x72,0x61,\n    0x6d,0x73,0x5b,0x33,0x5d,0x29,0x20,0x2a,0x20,0x76,0x65,0x63,0x34,0x28,0x28,0x70,\n    0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x2a,0x20,0x31,0x36,0x2e,0x30,0x29,0x20,\n    0x2b,0x20,0x70,0x6f,0x73,0x2e,0x78,0x79,0x7a,0x2c,0x20,0x31,0x2e,0x30,0x29,0x3b,\n    0x0a,0x20,0x20,0x20,0x20,0x69,0x64,0x20,0x3d,0x20,0x70,0x6f,0x73,0x2e,0x77,0x3b,\n    0x0a,0x20,0x20,0x20,0x20,0x75,0x76,0x20,0x3d,0x20,0x75,0x76,0x5f,0x63,0x6f,0x6f,\n    0x72,0x64,0x73,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,0x63,0x6f,0x6c,0x6f,0x72,0x20,\n    0x3d,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,\n};\n//\n//    #version 430\n//\n//    uniform vec4 fs_params[1];\n//    layout(binding = 16) uniform sampler2D tex2d_smp;\n//\n//    layout(location = 1) in float id;\n//    layout(location = 0) in vec2 uv;\n//    layout(location = 2) in vec4 ocolor;\n//    layout(location = 0) out vec4 frag_color;\n//\n//    void main()\n//    {\n//        float _30 = fs_params[0].x / fs_params[0].z;\n//        vec4 _90 = texture(tex2d_smp, fma(vec2(uv.x, uv.y), fs_params[0].zw, vec2(mod(id, _30) * fs_params[0].z, (((fs_params[0].y / fs_params[0].w) - 1.0) - floor(id / _30)) * fs_params[0].w)) / fs_params[0].xy);\n//        bvec4 _103 = bvec4(_90.w > 0.100000001490116119384765625);\n//        frag_color = vec4(_103.x ? _90.x : ocolor.x, _103.y ? _90.y : ocolor.y, _103.z ? _90.z : ocolor.z, _103.w ? _90.w : ocolor.w);\n//    }\n//\n//\nconst fs_source_glsl430 = [710]u8 {\n    0x23,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,0x34,0x33,0x30,0x0a,0x0a,0x75,0x6e,\n    0x69,0x66,0x6f,0x72,0x6d,0x20,0x76,0x65,0x63,0x34,0x20,0x66,0x73,0x5f,0x70,0x61,\n    0x72,0x61,0x6d,0x73,0x5b,0x31,0x5d,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,\n    0x62,0x69,0x6e,0x64,0x69,0x6e,0x67,0x20,0x3d,0x20,0x31,0x36,0x29,0x20,0x75,0x6e,\n    0x69,0x66,0x6f,0x72,0x6d,0x20,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,0x32,0x44,0x20,\n    0x74,0x65,0x78,0x32,0x64,0x5f,0x73,0x6d,0x70,0x3b,0x0a,0x0a,0x6c,0x61,0x79,0x6f,\n    0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x31,0x29,\n    0x20,0x69,0x6e,0x20,0x66,0x6c,0x6f,0x61,0x74,0x20,0x69,0x64,0x3b,0x0a,0x6c,0x61,\n    0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,\n    0x30,0x29,0x20,0x69,0x6e,0x20,0x76,0x65,0x63,0x32,0x20,0x75,0x76,0x3b,0x0a,0x6c,\n    0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,0x69,0x6f,0x6e,0x20,0x3d,\n    0x20,0x32,0x29,0x20,0x69,0x6e,0x20,0x76,0x65,0x63,0x34,0x20,0x6f,0x63,0x6f,0x6c,\n    0x6f,0x72,0x3b,0x0a,0x6c,0x61,0x79,0x6f,0x75,0x74,0x28,0x6c,0x6f,0x63,0x61,0x74,\n    0x69,0x6f,0x6e,0x20,0x3d,0x20,0x30,0x29,0x20,0x6f,0x75,0x74,0x20,0x76,0x65,0x63,\n    0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x3b,0x0a,0x0a,0x76,\n    0x6f,0x69,0x64,0x20,0x6d,0x61,0x69,0x6e,0x28,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,\n    0x20,0x66,0x6c,0x6f,0x61,0x74,0x20,0x5f,0x33,0x30,0x20,0x3d,0x20,0x66,0x73,0x5f,\n    0x70,0x61,0x72,0x61,0x6d,0x73,0x5b,0x30,0x5d,0x2e,0x78,0x20,0x2f,0x20,0x66,0x73,\n    0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x5b,0x30,0x5d,0x2e,0x7a,0x3b,0x0a,0x20,0x20,\n    0x20,0x20,0x76,0x65,0x63,0x34,0x20,0x5f,0x39,0x30,0x20,0x3d,0x20,0x74,0x65,0x78,\n    0x74,0x75,0x72,0x65,0x28,0x74,0x65,0x78,0x32,0x64,0x5f,0x73,0x6d,0x70,0x2c,0x20,\n    0x66,0x6d,0x61,0x28,0x76,0x65,0x63,0x32,0x28,0x75,0x76,0x2e,0x78,0x2c,0x20,0x75,\n    0x76,0x2e,0x79,0x29,0x2c,0x20,0x66,0x73,0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x5b,\n    0x30,0x5d,0x2e,0x7a,0x77,0x2c,0x20,0x76,0x65,0x63,0x32,0x28,0x6d,0x6f,0x64,0x28,\n    0x69,0x64,0x2c,0x20,0x5f,0x33,0x30,0x29,0x20,0x2a,0x20,0x66,0x73,0x5f,0x70,0x61,\n    0x72,0x61,0x6d,0x73,0x5b,0x30,0x5d,0x2e,0x7a,0x2c,0x20,0x28,0x28,0x28,0x66,0x73,\n    0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x5b,0x30,0x5d,0x2e,0x79,0x20,0x2f,0x20,0x66,\n    0x73,0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x5b,0x30,0x5d,0x2e,0x77,0x29,0x20,0x2d,\n    0x20,0x31,0x2e,0x30,0x29,0x20,0x2d,0x20,0x66,0x6c,0x6f,0x6f,0x72,0x28,0x69,0x64,\n    0x20,0x2f,0x20,0x5f,0x33,0x30,0x29,0x29,0x20,0x2a,0x20,0x66,0x73,0x5f,0x70,0x61,\n    0x72,0x61,0x6d,0x73,0x5b,0x30,0x5d,0x2e,0x77,0x29,0x29,0x20,0x2f,0x20,0x66,0x73,\n    0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x5b,0x30,0x5d,0x2e,0x78,0x79,0x29,0x3b,0x0a,\n    0x20,0x20,0x20,0x20,0x62,0x76,0x65,0x63,0x34,0x20,0x5f,0x31,0x30,0x33,0x20,0x3d,\n    0x20,0x62,0x76,0x65,0x63,0x34,0x28,0x5f,0x39,0x30,0x2e,0x77,0x20,0x3e,0x20,0x30,\n    0x2e,0x31,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x31,0x34,0x39,0x30,0x31,0x31,0x36,\n    0x31,0x31,0x39,0x33,0x38,0x34,0x37,0x36,0x35,0x36,0x32,0x35,0x29,0x3b,0x0a,0x20,\n    0x20,0x20,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,\n    0x76,0x65,0x63,0x34,0x28,0x5f,0x31,0x30,0x33,0x2e,0x78,0x20,0x3f,0x20,0x5f,0x39,\n    0x30,0x2e,0x78,0x20,0x3a,0x20,0x6f,0x63,0x6f,0x6c,0x6f,0x72,0x2e,0x78,0x2c,0x20,\n    0x5f,0x31,0x30,0x33,0x2e,0x79,0x20,0x3f,0x20,0x5f,0x39,0x30,0x2e,0x79,0x20,0x3a,\n    0x20,0x6f,0x63,0x6f,0x6c,0x6f,0x72,0x2e,0x79,0x2c,0x20,0x5f,0x31,0x30,0x33,0x2e,\n    0x7a,0x20,0x3f,0x20,0x5f,0x39,0x30,0x2e,0x7a,0x20,0x3a,0x20,0x6f,0x63,0x6f,0x6c,\n    0x6f,0x72,0x2e,0x7a,0x2c,0x20,0x5f,0x31,0x30,0x33,0x2e,0x77,0x20,0x3f,0x20,0x5f,\n    0x39,0x30,0x2e,0x77,0x20,0x3a,0x20,0x6f,0x63,0x6f,0x6c,0x6f,0x72,0x2e,0x77,0x29,\n    0x3b,0x0a,0x7d,0x0a,0x0a,0x00,\n};\n//\n//    #include <metal_stdlib>\n//    #include <simd/simd.h>\n//\n//    using namespace metal;\n//\n//    struct vs_params\n//    {\n//        float4x4 mvp;\n//    };\n//\n//    struct main0_out\n//    {\n//        float2 uv [[user(locn0)]];\n//        float id [[user(locn1)]];\n//        float4 ocolor [[user(locn2)]];\n//        float4 gl_Position [[position]];\n//    };\n//\n//    struct main0_in\n//    {\n//        float3 position [[attribute(0)]];\n//        float2 uv_coords [[attribute(1)]];\n//        float4 pos [[attribute(2)]];\n//        float4 color [[attribute(3)]];\n//    };\n//\n//    vertex main0_out main0(main0_in in [[stage_in]], constant vs_params& _19 [[buffer(0)]])\n//    {\n//        main0_out out = {};\n//        out.gl_Position = _19.mvp * float4((in.position * 16.0) + in.pos.xyz, 1.0);\n//        out.id = in.pos.w;\n//        out.uv = in.uv_coords;\n//        out.ocolor = in.color;\n//        return out;\n//    }\n//\n//\nconst vs_source_metal_macos = [727]u8 {\n    0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,\n    0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,\n    0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,\n    0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,\n    0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x76,\n    0x73,0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,\n    0x6c,0x6f,0x61,0x74,0x34,0x78,0x34,0x20,0x6d,0x76,0x70,0x3b,0x0a,0x7d,0x3b,0x0a,\n    0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,\n    0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x75,\n    0x76,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x30,0x29,0x5d,\n    0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x20,0x69,0x64,0x20,\n    0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x31,0x29,0x5d,0x5d,0x3b,\n    0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x6f,0x63,0x6f,0x6c,\n    0x6f,0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x32,0x29,\n    0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x67,\n    0x6c,0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x5b,0x5b,0x70,0x6f,0x73,\n    0x69,0x74,0x69,0x6f,0x6e,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,\n    0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x0a,0x7b,0x0a,0x20,\n    0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x33,0x20,0x70,0x6f,0x73,0x69,0x74,0x69,\n    0x6f,0x6e,0x20,0x5b,0x5b,0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x28,0x30,\n    0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,\n    0x75,0x76,0x5f,0x63,0x6f,0x6f,0x72,0x64,0x73,0x20,0x5b,0x5b,0x61,0x74,0x74,0x72,\n    0x69,0x62,0x75,0x74,0x65,0x28,0x31,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,0x20,\n    0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x70,0x6f,0x73,0x20,0x5b,0x5b,0x61,0x74,0x74,\n    0x72,0x69,0x62,0x75,0x74,0x65,0x28,0x32,0x29,0x5d,0x5d,0x3b,0x0a,0x20,0x20,0x20,\n    0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,0x5b,\n    0x61,0x74,0x74,0x72,0x69,0x62,0x75,0x74,0x65,0x28,0x33,0x29,0x5d,0x5d,0x3b,0x0a,\n    0x7d,0x3b,0x0a,0x0a,0x76,0x65,0x72,0x74,0x65,0x78,0x20,0x6d,0x61,0x69,0x6e,0x30,\n    0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x28,0x6d,0x61,0x69,0x6e,0x30,\n    0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,0x5b,0x5b,0x73,0x74,0x61,0x67,0x65,0x5f,0x69,\n    0x6e,0x5d,0x5d,0x2c,0x20,0x63,0x6f,0x6e,0x73,0x74,0x61,0x6e,0x74,0x20,0x76,0x73,\n    0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x26,0x20,0x5f,0x31,0x39,0x20,0x5b,0x5b,0x62,\n    0x75,0x66,0x66,0x65,0x72,0x28,0x30,0x29,0x5d,0x5d,0x29,0x0a,0x7b,0x0a,0x20,0x20,\n    0x20,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6f,0x75,0x74,0x20,\n    0x3d,0x20,0x7b,0x7d,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x67,0x6c,\n    0x5f,0x50,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x3d,0x20,0x5f,0x31,0x39,0x2e,\n    0x6d,0x76,0x70,0x20,0x2a,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x28,0x28,0x69,0x6e,\n    0x2e,0x70,0x6f,0x73,0x69,0x74,0x69,0x6f,0x6e,0x20,0x2a,0x20,0x31,0x36,0x2e,0x30,\n    0x29,0x20,0x2b,0x20,0x69,0x6e,0x2e,0x70,0x6f,0x73,0x2e,0x78,0x79,0x7a,0x2c,0x20,\n    0x31,0x2e,0x30,0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x69,0x64,\n    0x20,0x3d,0x20,0x69,0x6e,0x2e,0x70,0x6f,0x73,0x2e,0x77,0x3b,0x0a,0x20,0x20,0x20,\n    0x20,0x6f,0x75,0x74,0x2e,0x75,0x76,0x20,0x3d,0x20,0x69,0x6e,0x2e,0x75,0x76,0x5f,\n    0x63,0x6f,0x6f,0x72,0x64,0x73,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,\n    0x6f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x69,0x6e,0x2e,0x63,0x6f,0x6c,0x6f,\n    0x72,0x3b,0x0a,0x20,0x20,0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,\n    0x74,0x3b,0x0a,0x7d,0x0a,0x0a,0x00,\n};\n//\n//    #pragma clang diagnostic ignored \"-Wmissing-prototypes\"\n//\n//    #include <metal_stdlib>\n//    #include <simd/simd.h>\n//\n//    using namespace metal;\n//\n//    // Implementation of the GLSL mod() function, which is slightly different than Metal fmod()\n//    template<typename Tx, typename Ty>\n//    inline Tx mod(Tx x, Ty y)\n//    {\n//        return x - y * floor(x / y);\n//    }\n//\n//    struct fs_params\n//    {\n//        float2 atlas_size;\n//        float2 sprite_size;\n//    };\n//\n//    struct main0_out\n//    {\n//        float4 frag_color [[color(0)]];\n//    };\n//\n//    struct main0_in\n//    {\n//        float2 uv [[user(locn0)]];\n//        float id [[user(locn1)]];\n//        float4 ocolor [[user(locn2)]];\n//    };\n//\n//    fragment main0_out main0(main0_in in [[stage_in]], constant fs_params& _12 [[buffer(0)]], texture2d<float> tex2d [[texture(0)]], sampler smp [[sampler(0)]])\n//    {\n//        main0_out out = {};\n//        float _30 = _12.atlas_size.x / _12.sprite_size.x;\n//        float4 _90 = tex2d.sample(smp, (fma(float2(in.uv.x, in.uv.y), _12.sprite_size, float2(mod(in.id, _30) * _12.sprite_size.x, (((_12.atlas_size.y / _12.sprite_size.y) - 1.0) - floor(in.id / _30)) * _12.sprite_size.y)) / _12.atlas_size));\n//        out.frag_color = select(in.ocolor, _90, bool4(_90.w > 0.100000001490116119384765625));\n//        return out;\n//    }\n//\n//\nconst fs_source_metal_macos = [1154]u8 {\n    0x23,0x70,0x72,0x61,0x67,0x6d,0x61,0x20,0x63,0x6c,0x61,0x6e,0x67,0x20,0x64,0x69,\n    0x61,0x67,0x6e,0x6f,0x73,0x74,0x69,0x63,0x20,0x69,0x67,0x6e,0x6f,0x72,0x65,0x64,\n    0x20,0x22,0x2d,0x57,0x6d,0x69,0x73,0x73,0x69,0x6e,0x67,0x2d,0x70,0x72,0x6f,0x74,\n    0x6f,0x74,0x79,0x70,0x65,0x73,0x22,0x0a,0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,\n    0x65,0x20,0x3c,0x6d,0x65,0x74,0x61,0x6c,0x5f,0x73,0x74,0x64,0x6c,0x69,0x62,0x3e,\n    0x0a,0x23,0x69,0x6e,0x63,0x6c,0x75,0x64,0x65,0x20,0x3c,0x73,0x69,0x6d,0x64,0x2f,\n    0x73,0x69,0x6d,0x64,0x2e,0x68,0x3e,0x0a,0x0a,0x75,0x73,0x69,0x6e,0x67,0x20,0x6e,\n    0x61,0x6d,0x65,0x73,0x70,0x61,0x63,0x65,0x20,0x6d,0x65,0x74,0x61,0x6c,0x3b,0x0a,\n    0x0a,0x2f,0x2f,0x20,0x49,0x6d,0x70,0x6c,0x65,0x6d,0x65,0x6e,0x74,0x61,0x74,0x69,\n    0x6f,0x6e,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x47,0x4c,0x53,0x4c,0x20,0x6d,\n    0x6f,0x64,0x28,0x29,0x20,0x66,0x75,0x6e,0x63,0x74,0x69,0x6f,0x6e,0x2c,0x20,0x77,\n    0x68,0x69,0x63,0x68,0x20,0x69,0x73,0x20,0x73,0x6c,0x69,0x67,0x68,0x74,0x6c,0x79,\n    0x20,0x64,0x69,0x66,0x66,0x65,0x72,0x65,0x6e,0x74,0x20,0x74,0x68,0x61,0x6e,0x20,\n    0x4d,0x65,0x74,0x61,0x6c,0x20,0x66,0x6d,0x6f,0x64,0x28,0x29,0x0a,0x74,0x65,0x6d,\n    0x70,0x6c,0x61,0x74,0x65,0x3c,0x74,0x79,0x70,0x65,0x6e,0x61,0x6d,0x65,0x20,0x54,\n    0x78,0x2c,0x20,0x74,0x79,0x70,0x65,0x6e,0x61,0x6d,0x65,0x20,0x54,0x79,0x3e,0x0a,\n    0x69,0x6e,0x6c,0x69,0x6e,0x65,0x20,0x54,0x78,0x20,0x6d,0x6f,0x64,0x28,0x54,0x78,\n    0x20,0x78,0x2c,0x20,0x54,0x79,0x20,0x79,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,\n    0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x78,0x20,0x2d,0x20,0x79,0x20,0x2a,0x20,0x66,\n    0x6c,0x6f,0x6f,0x72,0x28,0x78,0x20,0x2f,0x20,0x79,0x29,0x3b,0x0a,0x7d,0x0a,0x0a,\n    0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x66,0x73,0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,\n    0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x61,0x74,\n    0x6c,0x61,0x73,0x5f,0x73,0x69,0x7a,0x65,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,\n    0x6f,0x61,0x74,0x32,0x20,0x73,0x70,0x72,0x69,0x74,0x65,0x5f,0x73,0x69,0x7a,0x65,\n    0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,\n    0x6e,0x30,0x5f,0x6f,0x75,0x74,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,\n    0x61,0x74,0x34,0x20,0x66,0x72,0x61,0x67,0x5f,0x63,0x6f,0x6c,0x6f,0x72,0x20,0x5b,\n    0x5b,0x63,0x6f,0x6c,0x6f,0x72,0x28,0x30,0x29,0x5d,0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,\n    0x0a,0x73,0x74,0x72,0x75,0x63,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,\n    0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x20,0x75,0x76,\n    0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x30,0x29,0x5d,0x5d,\n    0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x20,0x69,0x64,0x20,0x5b,\n    0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x31,0x29,0x5d,0x5d,0x3b,0x0a,\n    0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x6f,0x63,0x6f,0x6c,0x6f,\n    0x72,0x20,0x5b,0x5b,0x75,0x73,0x65,0x72,0x28,0x6c,0x6f,0x63,0x6e,0x32,0x29,0x5d,\n    0x5d,0x3b,0x0a,0x7d,0x3b,0x0a,0x0a,0x66,0x72,0x61,0x67,0x6d,0x65,0x6e,0x74,0x20,\n    0x6d,0x61,0x69,0x6e,0x30,0x5f,0x6f,0x75,0x74,0x20,0x6d,0x61,0x69,0x6e,0x30,0x28,\n    0x6d,0x61,0x69,0x6e,0x30,0x5f,0x69,0x6e,0x20,0x69,0x6e,0x20,0x5b,0x5b,0x73,0x74,\n    0x61,0x67,0x65,0x5f,0x69,0x6e,0x5d,0x5d,0x2c,0x20,0x63,0x6f,0x6e,0x73,0x74,0x61,\n    0x6e,0x74,0x20,0x66,0x73,0x5f,0x70,0x61,0x72,0x61,0x6d,0x73,0x26,0x20,0x5f,0x31,\n    0x32,0x20,0x5b,0x5b,0x62,0x75,0x66,0x66,0x65,0x72,0x28,0x30,0x29,0x5d,0x5d,0x2c,\n    0x20,0x74,0x65,0x78,0x74,0x75,0x72,0x65,0x32,0x64,0x3c,0x66,0x6c,0x6f,0x61,0x74,\n    0x3e,0x20,0x74,0x65,0x78,0x32,0x64,0x20,0x5b,0x5b,0x74,0x65,0x78,0x74,0x75,0x72,\n    0x65,0x28,0x30,0x29,0x5d,0x5d,0x2c,0x20,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,0x20,\n    0x73,0x6d,0x70,0x20,0x5b,0x5b,0x73,0x61,0x6d,0x70,0x6c,0x65,0x72,0x28,0x30,0x29,\n    0x5d,0x5d,0x29,0x0a,0x7b,0x0a,0x20,0x20,0x20,0x20,0x6d,0x61,0x69,0x6e,0x30,0x5f,\n    0x6f,0x75,0x74,0x20,0x6f,0x75,0x74,0x20,0x3d,0x20,0x7b,0x7d,0x3b,0x0a,0x20,0x20,\n    0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x20,0x5f,0x33,0x30,0x20,0x3d,0x20,0x5f,0x31,\n    0x32,0x2e,0x61,0x74,0x6c,0x61,0x73,0x5f,0x73,0x69,0x7a,0x65,0x2e,0x78,0x20,0x2f,\n    0x20,0x5f,0x31,0x32,0x2e,0x73,0x70,0x72,0x69,0x74,0x65,0x5f,0x73,0x69,0x7a,0x65,\n    0x2e,0x78,0x3b,0x0a,0x20,0x20,0x20,0x20,0x66,0x6c,0x6f,0x61,0x74,0x34,0x20,0x5f,\n    0x39,0x30,0x20,0x3d,0x20,0x74,0x65,0x78,0x32,0x64,0x2e,0x73,0x61,0x6d,0x70,0x6c,\n    0x65,0x28,0x73,0x6d,0x70,0x2c,0x20,0x28,0x66,0x6d,0x61,0x28,0x66,0x6c,0x6f,0x61,\n    0x74,0x32,0x28,0x69,0x6e,0x2e,0x75,0x76,0x2e,0x78,0x2c,0x20,0x69,0x6e,0x2e,0x75,\n    0x76,0x2e,0x79,0x29,0x2c,0x20,0x5f,0x31,0x32,0x2e,0x73,0x70,0x72,0x69,0x74,0x65,\n    0x5f,0x73,0x69,0x7a,0x65,0x2c,0x20,0x66,0x6c,0x6f,0x61,0x74,0x32,0x28,0x6d,0x6f,\n    0x64,0x28,0x69,0x6e,0x2e,0x69,0x64,0x2c,0x20,0x5f,0x33,0x30,0x29,0x20,0x2a,0x20,\n    0x5f,0x31,0x32,0x2e,0x73,0x70,0x72,0x69,0x74,0x65,0x5f,0x73,0x69,0x7a,0x65,0x2e,\n    0x78,0x2c,0x20,0x28,0x28,0x28,0x5f,0x31,0x32,0x2e,0x61,0x74,0x6c,0x61,0x73,0x5f,\n    0x73,0x69,0x7a,0x65,0x2e,0x79,0x20,0x2f,0x20,0x5f,0x31,0x32,0x2e,0x73,0x70,0x72,\n    0x69,0x74,0x65,0x5f,0x73,0x69,0x7a,0x65,0x2e,0x79,0x29,0x20,0x2d,0x20,0x31,0x2e,\n    0x30,0x29,0x20,0x2d,0x20,0x66,0x6c,0x6f,0x6f,0x72,0x28,0x69,0x6e,0x2e,0x69,0x64,\n    0x20,0x2f,0x20,0x5f,0x33,0x30,0x29,0x29,0x20,0x2a,0x20,0x5f,0x31,0x32,0x2e,0x73,\n    0x70,0x72,0x69,0x74,0x65,0x5f,0x73,0x69,0x7a,0x65,0x2e,0x79,0x29,0x29,0x20,0x2f,\n    0x20,0x5f,0x31,0x32,0x2e,0x61,0x74,0x6c,0x61,0x73,0x5f,0x73,0x69,0x7a,0x65,0x29,\n    0x29,0x3b,0x0a,0x20,0x20,0x20,0x20,0x6f,0x75,0x74,0x2e,0x66,0x72,0x61,0x67,0x5f,\n    0x63,0x6f,0x6c,0x6f,0x72,0x20,0x3d,0x20,0x73,0x65,0x6c,0x65,0x63,0x74,0x28,0x69,\n    0x6e,0x2e,0x6f,0x63,0x6f,0x6c,0x6f,0x72,0x2c,0x20,0x5f,0x39,0x30,0x2c,0x20,0x62,\n    0x6f,0x6f,0x6c,0x34,0x28,0x5f,0x39,0x30,0x2e,0x77,0x20,0x3e,0x20,0x30,0x2e,0x31,\n    0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x31,0x34,0x39,0x30,0x31,0x31,0x36,0x31,0x31,\n    0x39,0x33,0x38,0x34,0x37,0x36,0x35,0x36,0x32,0x35,0x29,0x29,0x3b,0x0a,0x20,0x20,\n    0x20,0x20,0x72,0x65,0x74,0x75,0x72,0x6e,0x20,0x6f,0x75,0x74,0x3b,0x0a,0x7d,0x0a,\n    0x0a,0x00,\n};\npub fn basicShaderDesc(backend: sg.Backend) sg.ShaderDesc {\n    var desc: sg.ShaderDesc = .{};\n    desc.label = \"basic_shader\";\n    switch (backend) {\n        .GLCORE => {\n            desc.vertex_func.source = &vs_source_glsl430;\n            desc.vertex_func.entry = \"main\";\n            desc.fragment_func.source = &fs_source_glsl430;\n            desc.fragment_func.entry = \"main\";\n            desc.attrs[0].glsl_name = \"position\";\n            desc.attrs[1].glsl_name = \"uv_coords\";\n            desc.attrs[2].glsl_name = \"pos\";\n            desc.attrs[3].glsl_name = \"color\";\n            desc.uniform_blocks[0].stage = .VERTEX;\n            desc.uniform_blocks[0].layout = .STD140;\n            desc.uniform_blocks[0].size = 64;\n            desc.uniform_blocks[0].glsl_uniforms[0].type = .FLOAT4;\n            desc.uniform_blocks[0].glsl_uniforms[0].array_count = 4;\n            desc.uniform_blocks[0].glsl_uniforms[0].glsl_name = \"vs_params\";\n            desc.uniform_blocks[1].stage = .FRAGMENT;\n            desc.uniform_blocks[1].layout = .STD140;\n            desc.uniform_blocks[1].size = 16;\n            desc.uniform_blocks[1].glsl_uniforms[0].type = .FLOAT4;\n            desc.uniform_blocks[1].glsl_uniforms[0].array_count = 1;\n            desc.uniform_blocks[1].glsl_uniforms[0].glsl_name = \"fs_params\";\n            desc.images[0].stage = .FRAGMENT;\n            desc.images[0].multisampled = false;\n            desc.images[0].image_type = ._2D;\n            desc.images[0].sample_type = .FLOAT;\n            desc.samplers[0].stage = .FRAGMENT;\n            desc.samplers[0].sampler_type = .FILTERING;\n            desc.image_sampler_pairs[0].stage = .FRAGMENT;\n            desc.image_sampler_pairs[0].image_slot = 0;\n            desc.image_sampler_pairs[0].sampler_slot = 0;\n            desc.image_sampler_pairs[0].glsl_name = \"tex2d_smp\";\n        },\n        .METAL_MACOS => {\n            desc.vertex_func.source = &vs_source_metal_macos;\n            desc.vertex_func.entry = \"main0\";\n            desc.fragment_func.source = &fs_source_metal_macos;\n            desc.fragment_func.entry = \"main0\";\n            desc.uniform_blocks[0].stage = .VERTEX;\n            desc.uniform_blocks[0].layout = .STD140;\n            desc.uniform_blocks[0].size = 64;\n            desc.uniform_blocks[0].msl_buffer_n = 0;\n            desc.uniform_blocks[1].stage = .FRAGMENT;\n            desc.uniform_blocks[1].layout = .STD140;\n            desc.uniform_blocks[1].size = 16;\n            desc.uniform_blocks[1].msl_buffer_n = 0;\n            desc.images[0].stage = .FRAGMENT;\n            desc.images[0].multisampled = false;\n            desc.images[0].image_type = ._2D;\n            desc.images[0].sample_type = .FLOAT;\n            desc.images[0].msl_texture_n = 0;\n            desc.samplers[0].stage = .FRAGMENT;\n            desc.samplers[0].sampler_type = .FILTERING;\n            desc.samplers[0].msl_sampler_n = 0;\n            desc.image_sampler_pairs[0].stage = .FRAGMENT;\n            desc.image_sampler_pairs[0].image_slot = 0;\n            desc.image_sampler_pairs[0].sampler_slot = 0;\n        },\n        else => {},\n    }\n    return desc;\n}\n"
                        "basic.glsl.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/shaders/basic.glsl.zig"
                        nil nil)
                       ("basic.glsl"
                        "@header const m = @import(\"../util/math.zig\")\n@ctype mat4 m.Mat4\n\n@vs vs\nlayout(binding=0) uniform vs_params {\n    mat4 mvp;\n};\n\nin vec3 position;\nin vec2 uv_coords;\nin vec4 pos;\nin vec4 color;\n\nout vec2 uv;\nout float id;\nout vec4 ocolor;\n\nvoid main() {\n    gl_Position = mvp * vec4((position * 16) + pos.xyz, 1.0);\n    id = pos.a;\n    uv = uv_coords;\n    ocolor = color;\n}\n@end\n\n@fs fs\nlayout(binding=0) uniform texture2D tex2d;\nlayout(binding=0) uniform sampler smp;\nlayout(binding=1) uniform fs_params {\n    vec2 atlas_size;\n    vec2 sprite_size;\n};\n\nin vec2 uv;\nin float id;\nin vec4 ocolor;\n\nout vec4 frag_color;\n\nvoid main() {\n    float total_rows = atlas_size.y / sprite_size.y;\n    float sprites_per_row = atlas_size.x / sprite_size.x;\n    float row = total_rows - 1.0 - floor(id / sprites_per_row);\n    float col = mod(id, sprites_per_row);\n\n    vec2 sprite_offset = vec2(col * sprite_size.x, row * sprite_size.y);\n    vec2 fixedTexCoord = vec2(uv.x, uv.y);\n\n    vec2 sprite_uv = (sprite_offset + fixedTexCoord * sprite_size) / atlas_size;\n\n    vec4 original = texture(sampler2D(tex2d, smp), sprite_uv);\n\n    vec4 finalColor = (original.a > 0.1)\n        ? original : ocolor;\n\n\n    frag_color = finalColor;\n}\n@end\n\n@program basic vs fs\n\n"
                        "basic.glsl" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/shaders/basic.glsl"
                        nil nil)))


;;; Snippet definitions:
;;;
(yas-define-snippets 'src
                     '(("tile.zig"
                        "const std = @import(\"std\");\nconst SpriteRenderable = @import(\"renderer.zig\").SpriteRenderable;\nconst util = @import(\"../util.zig\");\nconst math = util.math;\n\n// @important  4 byte alignement 44 bytes\nconst Self = @This();\npos: math.Vec2i = .{}, // 8 bytes\nsprite_renderable: SpriteRenderable = .{\n    .pos = .{ .x = 0, .y = 0, .z = 0 },\n    .sprite_id = 0,\n    .color = .{ .x = 0, .y = 0, .z = 0, .w = 0 },\n}, // 32 bytes\nspawner: bool = false,\ntraversable: bool = false,\n\npub fn jsonStringify(self: *const Self, jws: anytype) !void {\n    try jws.beginObject();\n    try jws.objectField(\"pos\");\n    try jws.beginObject();\n    try jws.objectField(\"x\");\n    try jws.print(\"{}\", .{self.pos.x});\n    try jws.objectField(\"y\");\n    try jws.print(\"{}\", .{self.pos.y});\n    try jws.endObject();\n\n    try jws.objectField(\"sprite_renderable\");\n    try self.sprite_renderable.jsonStringify(jws);\n\n    try jws.objectField(\"spawner\");\n    try jws.write(self.spawner);\n\n    try jws.objectField(\"traversable\");\n    try jws.write(self.traversable);\n\n    try jws.endObject();\n}\n\n//pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n//    // @todo finish parsing\n//    _ = options;\n//\n//    var self: Self = .{};\n//    if (try source.next() != .object_begin) {\n//        return error.UnexpectedToken;\n//    }\n//\n//    switch (try source.nextAlloc(allocator, .alloc_if_needed)) {\n//        .string, .allocated_string => |token| {\n//            std.log.info(\"token: {s}\", .{token});\n//            if (!std.mem.eql(u8, token, \"pos\")) {\n//                return error.UnexpectedToken;\n//            }\n//        },\n//        else => return error.UnexpectedToken,\n//    }\n//\n//    // POS parsing\n//    if (try source.next() != .object_begin) {\n//        return error.UnexpectedToken;\n//    }\n//    switch (try source.nextAlloc(allocator, .alloc_if_needed)) {\n//        .string, .allocated_string => |token| {\n//            if (!std.mem.eql(u8, token, \"x\")) {\n//                return error.UnexpectedToken;\n//            }\n//        },\n//        else => return error.UnexpectedToken,\n//    }\n//    switch (try source.nextAlloc(allocator, .alloc_if_needed)) {\n//        .number, .allocated_number => |token| {\n//            self.pos.x = token;\n//        },\n//        else => return error.UnexpectedToken,\n//    }\n//    switch (try source.nextAlloc(allocator, .alloc_if_needed)) {\n//        .string, .allocated_string => |token| {\n//            if (!std.mem.eql(u8, token, \"y\")) {\n//                return error.UnexpectedToken;\n//            }\n//        },\n//        else => return error.UnexpectedToken,\n//    }\n//    switch (try source.nextAlloc(allocator, .alloc_if_needed)) {\n//        .number, .allocated_number => |token| {\n//            self.pos.y = token;\n//        },\n//        else => return error.UnexpectedToken,\n//    }\n//    if (try source.next() != .object_end) {\n//        return error.UnexpectedToken;\n//    }\n//\n//    if (try source.next() != .object_end) {\n//        return error.UnexpectedToken;\n//    }\n//\n//    return .{};\n//}\n"
                        "tile.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/types/tile.zig"
                        nil nil)
                       ("scene.zig"
                        "const std = @import(\"std\");\nconst assert = std.debug.assert;\nconst testing = std.testing;\n\nconst State = @import(\"../state.zig\");\nconst Entity = @import(\"entity.zig\");\nconst Renderer = @import(\"../renderer.zig\");\nconst RendererTypes = @import(\"renderer.zig\");\nconst Tile = @import(\"tile.zig\");\nconst log = std.log.scoped(.scene);\n\n/// There is a lot for this class. The main idea is that we construct\n/// scenes similar to the way Godot handles scenes, but some more simple.\nconst Self = @This();\nid: u32 = 0,\nheight: f32 = 0,\nwidth: f32 = 0,\nscene_name: []const u8 = \"\",\nentities: std.MultiArrayList(Entity) = .{},\ntiles: std.MultiArrayList(Tile) = .{},\n\npub fn default(self: *Self, allocator: std.mem.Allocator, state: *State) !void {\n    self.id = 0;\n    self.height = 16.0;\n    self.width = 16.0;\n    self.scene_name = \"Default Scene\";\n\n    try self.tiles.append(allocator, .{\n        .sprite_renderable = .{\n            .pos = .{\n                .x = 0,\n                .y = 0,\n                .z = 0,\n            },\n            .sprite_id = 0,\n            .color = .{\n                .x = 1.0,\n                .y = 1.0,\n                .z = 1.0,\n                .w = 1.0,\n            },\n        },\n    });\n    for (self.tiles.items(.sprite_renderable)) |i| {\n        try state.passes[0].appendSpriteToBatch(i);\n    }\n}\n\npub fn loadTestScene(\n    self: *Self,\n    allocator: std.mem.Allocator,\n    state: *State,\n) !void {\n    _ = state;\n    self.id = 0;\n    var file = try std.fs.cwd().openFile(\"levels/t1.txt\", .{});\n    defer file.close();\n\n    var reader = file.reader();\n\n    self.scene_name = \"Test Level\";\n    try reader.context.seekTo(0);\n\n    const width = try reader.readUntilDelimiterAlloc(allocator, '\\n', 40);\n    defer allocator.free(width);\n    const height = try reader.readUntilDelimiterAlloc(allocator, '\\n', 40);\n    defer allocator.free(height);\n    self.width = try std.fmt.parseFloat(f32, width);\n    self.height = try std.fmt.parseFloat(f32, height);\n\n    var y: f32 = 0;\n    while (try reader.readUntilDelimiterOrEofAlloc(allocator, '\\n', 10_000)) |line| {\n        for (0.., line) |i, char| {\n            const f: f32 = @floatFromInt(i);\n            try self.tiles.append(allocator, .{\n                .sprite_renderable = .{\n                    .pos = .{\n                        .x = f * 16,\n                        .y = y,\n                        .z = 0,\n                    },\n                    .sprite_id = @floatFromInt(char),\n                    .color = .{\n                        .x = 1,\n                        .y = 1,\n                        .z = 1,\n                        .w = 1,\n                    },\n                },\n            });\n        }\n        y += 16;\n    }\n\n    log.info(\"Scene: tiles: {}\", .{self.tiles.len});\n\n    //for (self.tiles.items(.sprite_renderable)) |i| {\n    //    try state.renderer.render_passes.items[@intFromEnum(RendererTypes.RenderPassIds.TILES_1)].appendSpriteToBatch(i);\n    //}\n\n    try self.writeSceneToBinary(\"t2.txt\");\n}\n\npub fn reloadScene(self: *Self, allocator: std.mem.Allocator) !void {\n    self.tiles.deinit(allocator);\n    self.tiles = .{};\n}\n\npub fn loadScene(self: *Self, renderer: *Renderer) !void {\n    for (self.tiles.items(.sprite_renderable)) |i| {\n        try renderer.render_passes.items[@intFromEnum(RendererTypes.RenderPassIds.TILES_1)].appendSpriteToBatch(i);\n    }\n}\n\npub fn saveScene(self: *Self) !void {\n    _ = self;\n}\n\npub fn renderScene(self: *Self) void {\n    _ = self;\n}\n\npub fn loadSceneToBinary(self: *Self, file_name: []const u8) !void {\n    assert(file_name.len > 0);\n    _ = self;\n    var level_dir = try std.fs.cwd().openDir(\"levels\", .{});\n\n    var file = try level_dir.openFile(file_name, .{});\n    defer file.close();\n    var buf: [4096]u8 = undefined;\n    var reader = file.reader();\n\n    const u = try reader.readUntilDelimiter(&buf, '\\n');\n    const len = std.mem.bytesToValue(usize, u);\n\n    for (0..len) |_| {\n        const sr = try reader.readStruct(Renderer.SpriteRenderable);\n        std.log.info(\"{any}\", .{sr});\n    }\n}\n\npub fn writeSceneToBinary(self: *Self, file_name: []const u8) !void {\n    assert(file_name.len > 0);\n    var level_dir = try std.fs.cwd().openDir(\"levels\", .{});\n\n    var file = try level_dir.createFile(file_name, .{});\n    defer file.close();\n\n    _ = try file.write(&std.mem.toBytes(self.id));\n    _ = try file.write(\"\\n\");\n    _ = try file.write(&std.mem.toBytes(self.width));\n    _ = try file.write(\"\\n\");\n    _ = try file.write(&std.mem.toBytes(self.height));\n    _ = try file.write(\"\\n\");\n    _ = try file.write(self.scene_name);\n    _ = try file.write(\"\\n\");\n\n    _ = try file.write(&std.mem.toBytes(self.entities.len));\n    _ = try file.write(\"\\n\");\n    for (0..self.entities.len) |t| {\n        _ = try file.write(&std.mem.toBytes(self.entities.get(t)));\n    }\n\n    _ = try file.write(&std.mem.toBytes(self.tiles.len));\n    _ = try file.write(\"\\n\");\n    for (0..self.tiles.len) |t| {\n        _ = try file.write(&std.mem.toBytes(self.tiles.get(t)));\n    }\n}\n\npub fn deloadScene(\n    self: *Self,\n    allocator: std.mem.Allocator,\n    state: *State,\n) void {\n    self.entities.deinit(allocator);\n    self.tiles.deinit(allocator);\n    for (state.renderer.render_passes.items) |*pass| {\n        pass.batch.clearAndFree();\n        pass.cur_num_of_sprite = 0;\n    }\n}\n\npub fn jsonStringify(self: *const Self, jws: anytype) !void {\n    try jws.beginObject();\n    try jws.objectField(\"id\");\n    try jws.print(\"{}\", .{self.id});\n    try jws.objectField(\"height\");\n    try jws.print(\"{}\", .{self.height});\n    try jws.objectField(\"width\");\n    try jws.print(\"{}\", .{self.width});\n    try jws.objectField(\"scene_name\");\n    try jws.print(\"{s}\", .{self.scene_name});\n    try jws.objectField(\"entities\");\n    try jws.beginArray();\n    for (0..self.entities.len) |i| {\n        var entity: Entity = self.entities.get(i);\n\n        try entity.jsonStringify(jws);\n    }\n    try jws.endArray();\n\n    try jws.objectField(\"tiles\");\n    try jws.beginArray();\n    for (0..self.tiles.len) |i| {\n        var tile: Tile = self.tiles.get(i);\n\n        try tile.jsonStringify(jws);\n    }\n    try jws.endArray();\n    try jws.endObject();\n}\n\ntest \"Scene serde\" {\n    try testing.expect(1 == 1);\n}\n"
                        "scene.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/types/scene.zig"
                        nil nil)
                       ("renderer.zig"
                        "const math = @import(\"../util.zig\").math;\n\npub const SpriteRenderable = extern struct {\n    pos: math.Vec3,\n    sprite_id: f32,\n    color: math.Vec4,\n\n    pub fn jsonStringify(self: *const SpriteRenderable, jws: anytype) !void {\n        try jws.beginObject();\n        try jws.objectField(\"pos\");\n        try jws.beginObject();\n        try jws.objectField(\"x\");\n        try jws.print(\"{}\", .{self.pos.x});\n        try jws.objectField(\"y\");\n        try jws.print(\"{}\", .{self.pos.y});\n        try jws.objectField(\"z\");\n        try jws.print(\"{}\", .{self.pos.z});\n        try jws.endObject();\n\n        try jws.objectField(\"sprite_id\");\n        try jws.print(\"{}\", .{self.sprite_id});\n\n        try jws.objectField(\"color\");\n        try jws.beginObject();\n        try jws.objectField(\"x\");\n        try jws.print(\"{}\", .{self.color.x});\n        try jws.objectField(\"y\");\n        try jws.print(\"{}\", .{self.color.y});\n        try jws.objectField(\"z\");\n        try jws.print(\"{}\", .{self.color.z});\n        try jws.objectField(\"w\");\n        try jws.print(\"{}\", .{self.color.w});\n        try jws.endObject();\n\n        try jws.endObject();\n    }\n};\n\npub const pass_count: u32 = 4;\n\npub const RenderPassIds = enum {\n    TILES_1,\n    TILES_2,\n    ENTITY_1,\n    UI_1,\n};\n"
                        "renderer.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/types/renderer.zig"
                        nil nil)
                       ("entity.zig"
                        "/// This is my generic entity class. All entities will belong to This\n/// class at the end of the day. Entities will be store via MultiArrayList\nconst std = @import(\"std\");\nconst Renderer = @import(\"renderer.zig\");\nconst SpriteRenderable = Renderer.SpriteRenderable;\nconst RenderPassIds = Renderer.RenderPassIds;\nconst util = @import(\"../util.zig\");\nconst math = util.math;\n\npub const EntityType = enum {\n    default,\n};\n\nconst AABB = struct {\n    min: math.Vec2,\n    max: math.Vec2,\n};\n\n// @important @incorrect_rendering We have to manually change serde formatting as we go.\nconst Self = @This();\nid: u32 = 10,\nspritesheet_id: RenderPassIds = .ENTITY_1,\nz_index: f32 = 0,\nentity_type: EntityType = .default,\npos: math.Vec2i = .{},\nsize: math.Vec2i = .{},\nsprite_id: f32 = 0,\naabb: AABB = .{\n    .min = math.Vec2.zero(),\n    .max = math.Vec2{ .x = 16, .y = 16 },\n},\nlua_script: []const u8 = \"\",\n// FLAGS\nselected: bool = false,\n\npub fn jsonStringify(self: *const Self, jws: anytype) !void {\n    try jws.beginObject();\n    try jws.objectField(\"id\");\n    try jws.print(\"{}\", .{self.id});\n    try jws.objectField(\"spritesheet_id\");\n    try jws.print(\"{s}\", .{@tagName(self.spritesheet_id)});\n    try jws.objectField(\"z_index\");\n    try jws.print(\"{}\", .{self.z_index});\n    try jws.objectField(\"entity_type\");\n    try jws.print(\"{s}\", .{@tagName(self.entity_type)});\n    try jws.objectField(\"pos\");\n    try jws.beginObject();\n    try jws.objectField(\"x\");\n    try jws.print(\"{}\", .{self.pos.x});\n    try jws.objectField(\"y\");\n    try jws.print(\"{}\", .{self.pos.y});\n    try jws.endObject();\n    try jws.objectField(\"size\");\n    try jws.beginObject();\n    try jws.objectField(\"x\");\n    try jws.print(\"{}\", .{self.size.x});\n    try jws.objectField(\"y\");\n    try jws.print(\"{}\", .{self.size.y});\n    try jws.endObject();\n    try jws.objectField(\"sprite_id\");\n    try jws.print(\"{}\", .{self.sprite_id});\n\n    // Start aabb\n    try jws.objectField(\"aabb\");\n    try jws.beginObject();\n    try jws.objectField(\"min\");\n    try jws.beginObject();\n    try jws.objectField(\"x\");\n    try jws.print(\"{}\", .{self.aabb.min.x});\n    try jws.objectField(\"y\");\n    try jws.print(\"{}\", .{self.aabb.min.y});\n    try jws.endObject();\n    try jws.objectField(\"max\");\n    try jws.beginObject();\n    try jws.objectField(\"x\");\n    try jws.print(\"{}\", .{self.aabb.max.x});\n    try jws.objectField(\"y\");\n    try jws.print(\"{}\", .{self.aabb.max.y});\n    try jws.endObject();\n    try jws.endObject();\n    // end aabb\n    //\n    try jws.objectField(\"lua_script\");\n    try jws.print(\"{s}\", .{self.lua_script});\n\n    try jws.objectField(\"selected\");\n    try jws.print(\"{}\", .{self.selected});\n\n    try jws.endObject();\n}\n\n//pub fn jsonParse(allocator: std.mem.Allocator, source: anytype, options: std.json.ParseOptions) !Self {\n//    _ = allocator;\n//    _ = source;\n//    _ = options;\n//    // @todo finish parsing\n//}\n\npub fn init(\n    self: *Self,\n    e_type: EntityType,\n) void {\n    _ = self;\n    _ = e_type;\n}\n\npub fn toSpriteRenderable(self: *const Self) SpriteRenderable {\n    return .{\n        .pos = .{\n            .x = @as(f32, @floatFromInt(self.pos.x * self.size.x)),\n            .y = @as(f32, @floatFromInt(self.pos.y * self.size.y)),\n            .z = self.z_index,\n        },\n        .sprite_id = self.sprite_id,\n        .color = .{ .x = 0.0, .y = 0.0, .z = 0.0, .w = 1.0 },\n    };\n}\n"
                        "entity.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/types/entity.zig"
                        nil nil)
                       ("camera.zig"
                        "const std = @import(\"std\");\n\nconst util = @import(\"../util.zig\");\nconst math = util.math;\nconst mat4 = math.Mat4;\nconst vec3 = math.Vec3;\n\npub const Camera = struct {\n    pos: vec3,\n    front: vec3,\n    up: vec3,\n    target: vec3,\n    vel: vec3,\n};\n"
                        "camera.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/types/camera.zig"
                        nil nil)))


;;; Snippet definitions:
;;;
(yas-define-snippets 'src
                     '(("math.zig"
                        "//------------------------------------------------------------------------------\n//  math.zig\n//\n//  minimal vector math helper functions, just the stuff needed for\n//  the sokol-samples\n//\n//  Ported from HandmadeMath.h\n//------------------------------------------------------------------------------\n//\n//  This has been extended to fit the needs of c-engine. Types have been\n//  added and is no longer the same as the original contents\n//\n//------------------------------------------------------------------------------\nconst assert = @import(\"std\").debug.assert;\nconst math = @import(\"std\").math;\n\nfn radians(deg: f32) f32 {\n    return deg * (math.pi / 180.0);\n}\n\npub const Vec4 = extern struct {\n    x: f32 = 0,\n    y: f32 = 0,\n    z: f32 = 0,\n    w: f32 = 0,\n\n    pub fn toArray(self: *const Vec4) [4]f32 {\n        return .{ self.x, self.y, self.z, self.w };\n    }\n\n    pub fn fromArray(arr: [4]f32) Vec4 {\n        return .{ .x = arr[0], .y = arr[1], .z = arr[2], .w = arr[3] };\n    }\n    pub fn zero() Vec4 {\n        return Vec4{ .x = 0.0, .y = 0.0, .z = 0.0, .w = 0.0 };\n    }\n\n    pub fn new(x: f32, y: f32, z: f32, w: f32) Vec4 {\n        return Vec4{ .x = x, .y = y, .z = z, .w = w };\n    }\n};\npub const Vec2i = extern struct {\n    x: i32 = 0,\n    y: i32 = 0,\n\n    pub fn zero() Vec2 {\n        return Vec2{ .x = 0.0, .y = 0.0 };\n    }\n\n    pub fn new(x: i32, y: i32) Vec2 {\n        return Vec2{ .x = x, .y = y };\n    }\n};\npub const Vec2 = extern struct {\n    x: f32,\n    y: f32,\n\n    pub fn zero() Vec2 {\n        return Vec2{ .x = 0.0, .y = 0.0 };\n    }\n\n    pub fn new(x: f32, y: f32) Vec2 {\n        return Vec2{ .x = x, .y = y };\n    }\n};\n\npub const Vec3 = extern struct {\n    x: f32,\n    y: f32,\n    z: f32,\n\n    pub fn zero() Vec3 {\n        return Vec3{ .x = 0.0, .y = 0.0, .z = 0.0 };\n    }\n\n    pub fn new(x: f32, y: f32, z: f32) Vec3 {\n        return Vec3{ .x = x, .y = y, .z = z };\n    }\n\n    pub fn up() Vec3 {\n        return Vec3{ .x = 0.0, .y = 1.0, .z = 0.0 };\n    }\n\n    pub fn len(v: Vec3) f32 {\n        return math.sqrt(Vec3.dot(v, v));\n    }\n\n    pub fn add(left: Vec3, right: Vec3) Vec3 {\n        return Vec3{ .x = left.x + right.x, .y = left.y + right.y, .z = left.z + right.z };\n    }\n\n    pub fn sub(left: Vec3, right: Vec3) Vec3 {\n        return Vec3{ .x = left.x - right.x, .y = left.y - right.y, .z = left.z - right.z };\n    }\n\n    pub fn mul(v: Vec3, s: f32) Vec3 {\n        return Vec3{ .x = v.x * s, .y = v.y * s, .z = v.z * s };\n    }\n\n    pub fn norm(v: Vec3) Vec3 {\n        const l = Vec3.len(v);\n        if (l != 0.0) {\n            return Vec3{ .x = v.x / l, .y = v.y / l, .z = v.z / l };\n        } else {\n            return Vec3.zero();\n        }\n    }\n\n    pub fn cross(v0: Vec3, v1: Vec3) Vec3 {\n        return Vec3{ .x = (v0.y * v1.z) - (v0.z * v1.y), .y = (v0.z * v1.x) - (v0.x * v1.z), .z = (v0.x * v1.y) - (v0.y * v1.x) };\n    }\n\n    pub fn dot(v0: Vec3, v1: Vec3) f32 {\n        return v0.x * v1.x + v0.y * v1.y + v0.z * v1.z;\n    }\n};\n\npub const Mat4 = extern struct {\n    m: [4][4]f32,\n\n    pub fn identity() Mat4 {\n        return Mat4{\n            .m = [_][4]f32{ .{ 1.0, 0.0, 0.0, 0.0 }, .{ 0.0, 1.0, 0.0, 0.0 }, .{ 0.0, 0.0, 1.0, 0.0 }, .{ 0.0, 0.0, 0.0, 1.0 } },\n        };\n    }\n\n    pub fn zero() Mat4 {\n        return Mat4{\n            .m = [_][4]f32{ .{ 0.0, 0.0, 0.0, 0.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, .{ 0.0, 0.0, 0.0, 0.0 }, .{ 0.0, 0.0, 0.0, 0.0 } },\n        };\n    }\n\n    pub fn mul(left: Mat4, right: Mat4) Mat4 {\n        var res = Mat4.zero();\n        var col: usize = 0;\n        while (col < 4) : (col += 1) {\n            var row: usize = 0;\n            while (row < 4) : (row += 1) {\n                res.m[col][row] = left.m[0][row] * right.m[col][0] +\n                    left.m[1][row] * right.m[col][1] +\n                    left.m[2][row] * right.m[col][2] +\n                    left.m[3][row] * right.m[col][3];\n            }\n        }\n        return res;\n    }\n\n    pub fn scale(scalar: Vec3) Mat4 {\n        var res = Mat4.identity();\n        res.m[0][0] = scalar.x;\n        res.m[1][1] = scalar.y;\n        res.m[2][2] = scalar.z;\n        return res;\n    }\n\n    pub fn persp(fov: f32, aspect: f32, near: f32, far: f32) Mat4 {\n        var res = Mat4.identity();\n        const t = math.tan(fov * (math.pi / 360.0));\n        res.m[0][0] = 1.0 / t;\n        res.m[1][1] = aspect / t;\n        res.m[2][3] = -1.0;\n        res.m[2][2] = (near + far) / (near - far);\n        res.m[3][2] = (2.0 * near * far) / (near - far);\n        res.m[3][3] = 0.0;\n        return res;\n    }\n\n    pub fn lookat(eye: Vec3, center: Vec3, up: Vec3) Mat4 {\n        var res = Mat4.zero();\n\n        const f = Vec3.norm(Vec3.sub(center, eye));\n        const s = Vec3.norm(Vec3.cross(f, up));\n        const u = Vec3.cross(s, f);\n\n        res.m[0][0] = s.x;\n        res.m[0][1] = u.x;\n        res.m[0][2] = -f.x;\n\n        res.m[1][0] = s.y;\n        res.m[1][1] = u.y;\n        res.m[1][2] = -f.y;\n\n        res.m[2][0] = s.z;\n        res.m[2][1] = u.z;\n        res.m[2][2] = -f.z;\n\n        res.m[3][0] = -Vec3.dot(s, eye);\n        res.m[3][1] = -Vec3.dot(u, eye);\n        res.m[3][2] = Vec3.dot(f, eye);\n        res.m[3][3] = 1.0;\n\n        return res;\n    }\n\n    pub fn rotate(angle: f32, axis_unorm: Vec3) Mat4 {\n        var res = Mat4.identity();\n\n        const axis = Vec3.norm(axis_unorm);\n        const sin_theta = math.sin(radians(angle));\n        const cos_theta = math.cos(radians(angle));\n        const cos_value = 1.0 - cos_theta;\n\n        res.m[0][0] = (axis.x * axis.x * cos_value) + cos_theta;\n        res.m[0][1] = (axis.x * axis.y * cos_value) + (axis.z * sin_theta);\n        res.m[0][2] = (axis.x * axis.z * cos_value) - (axis.y * sin_theta);\n        res.m[1][0] = (axis.y * axis.x * cos_value) - (axis.z * sin_theta);\n        res.m[1][1] = (axis.y * axis.y * cos_value) + cos_theta;\n        res.m[1][2] = (axis.y * axis.z * cos_value) + (axis.x * sin_theta);\n        res.m[2][0] = (axis.z * axis.x * cos_value) + (axis.y * sin_theta);\n        res.m[2][1] = (axis.z * axis.y * cos_value) - (axis.x * sin_theta);\n        res.m[2][2] = (axis.z * axis.z * cos_value) + cos_theta;\n\n        return res;\n    }\n\n    pub fn translate(translation: Vec3) Mat4 {\n        var res = Mat4.identity();\n        res.m[3][0] = translation.x;\n        res.m[3][1] = translation.y;\n        res.m[3][2] = translation.z;\n        return res;\n    }\n\n    pub fn ortho(left: f32, right: f32, bottom: f32, top: f32, near: f32, far: f32) Mat4 {\n        var res = Mat4.identity();\n        res.m[0][0] = 2.0 / (right - left);\n        res.m[1][1] = 2.0 / (top - bottom);\n        res.m[2][2] = -2.0 / (far - near);\n        res.m[3][0] = -(right + left) / (right - left);\n        res.m[3][1] = -(top + bottom) / (top - bottom);\n        res.m[3][2] = (far + near) / (far - near);\n        res.m[3][3] = 1;\n        return res;\n    }\n\n    pub fn mulByVec4(mat: Mat4, vec: Vec4) Vec4 {\n        return Vec4{\n            .x = mat.m[0][0] * vec.x + mat.m[1][0] * vec.y + mat.m[2][0] * vec.z + mat.m[3][0] * vec.w,\n            .y = mat.m[0][1] * vec.x + mat.m[1][1] * vec.y + mat.m[2][1] * vec.z + mat.m[3][1] * vec.w,\n            .z = mat.m[0][2] * vec.x + mat.m[1][2] * vec.y + mat.m[2][2] * vec.z + mat.m[3][2] * vec.w,\n            .w = mat.m[0][3] * vec.x + mat.m[1][3] * vec.y + mat.m[2][3] * vec.z + mat.m[3][3] * vec.w,\n        };\n    }\n\n    pub fn inverse(mat: Mat4) Mat4 {\n        var inv: [16]f32 = undefined;\n        const m = &mat.m;\n\n        inv[0] = m[1][1] * m[2][2] * m[3][3] - m[1][1] * m[2][3] * m[3][2] - m[2][1] * m[1][2] * m[3][3] +\n            m[2][1] * m[1][3] * m[3][2] + m[3][1] * m[1][2] * m[2][3] - m[3][1] * m[1][3] * m[2][2];\n\n        inv[4] = -m[1][0] * m[2][2] * m[3][3] + m[1][0] * m[2][3] * m[3][2] + m[2][0] * m[1][2] * m[3][3] -\n            m[2][0] * m[1][3] * m[3][2] - m[3][0] * m[1][2] * m[2][3] + m[3][0] * m[1][3] * m[2][2];\n\n        inv[8] = m[1][0] * m[2][1] * m[3][3] - m[1][0] * m[2][3] * m[3][1] - m[2][0] * m[1][1] * m[3][3] +\n            m[2][0] * m[1][3] * m[3][1] + m[3][0] * m[1][1] * m[2][3] - m[3][0] * m[1][3] * m[2][1];\n\n        inv[12] = -m[1][0] * m[2][1] * m[3][2] + m[1][0] * m[2][2] * m[3][1] + m[2][0] * m[1][1] * m[3][2] -\n            m[2][0] * m[1][2] * m[3][1] - m[3][0] * m[1][1] * m[2][2] + m[3][0] * m[1][2] * m[2][1];\n\n        const det = m[0][0] * inv[0] + m[0][1] * inv[4] + m[0][2] * inv[8] + m[0][3] * inv[12];\n\n        if (det == 0.0) {\n            return Mat4.identity(); // Non-invertible matrix\n        }\n\n        const inv_det = 1.0 / det;\n\n        for (0..4) |i| {\n            for (0..4) |j| {\n                const idx = i * 4 + j;\n                if (idx != 0 and idx != 4 and idx != 8 and idx != 12) {\n                    inv[idx] = (m[(j + 1) % 4][(i + 1) % 4] * (m[(j + 2) % 4][(i + 2) % 4] * m[(j + 3) % 4][(i + 3) % 4] -\n                        m[(j + 2) % 4][(i + 3) % 4] * m[(j + 3) % 4][(i + 2) % 4]) -\n                        m[(j + 1) % 4][(i + 2) % 4] * (m[(j + 2) % 4][(i + 1) % 4] * m[(j + 3) % 4][(i + 3) % 4] -\n                            m[(j + 2) % 4][(i + 3) % 4] * m[(j + 3) % 4][(i + 1) % 4]) +\n                        m[(j + 1) % 4][(i + 3) % 4] * (m[(j + 2) % 4][(i + 1) % 4] * m[(j + 3) % 4][(i + 2) % 4] -\n                            m[(j + 2) % 4][(i + 2) % 4] * m[(j + 3) % 4][(i + 1) % 4]));\n                }\n            }\n        }\n\n        var inv_mat = Mat4.zero();\n        for (0..4) |col| {\n            for (0..4) |row| {\n                inv_mat.m[col][row] = inv[col * 4 + row] * inv_det;\n            }\n        }\n\n        return inv_mat;\n    }\n};\n\ntest \"Vec3.zero\" {\n    const v = Vec3.zero();\n    assert(v.x == 0.0 and v.y == 0.0 and v.z == 0.0);\n}\n\ntest \"Vec3.new\" {\n    const v = Vec3.new(1.0, 2.0, 3.0);\n    assert(v.x == 1.0 and v.y == 2.0 and v.z == 3.0);\n}\n\ntest \"Mat4.ident\" {\n    const m = Mat4.identity();\n    for (m.m, 0..) |row, y| {\n        for (row, 0..) |val, x| {\n            if (x == y) {\n                assert(val == 1.0);\n            } else {\n                assert(val == 0.0);\n            }\n        }\n    }\n}\n\ntest \"Mat4.mul\" {\n    const l = Mat4.identity();\n    const r = Mat4.identity();\n    const m = Mat4.mul(l, r);\n    for (m.m, 0..) |row, y| {\n        for (row, 0..) |val, x| {\n            if (x == y) {\n                assert(val == 1.0);\n            } else {\n                assert(val == 0.0);\n            }\n        }\n    }\n}\n\nfn eq(val: f32, cmp: f32) bool {\n    const delta: f32 = 0.00001;\n    return (val > (cmp - delta)) and (val < (cmp + delta));\n}\n\ntest \"Mat4.persp\" {\n    const m = Mat4.persp(60.0, 1.33333337, 0.01, 10.0);\n\n    assert(eq(m.m[0][0], 1.73205));\n    assert(eq(m.m[0][1], 0.0));\n    assert(eq(m.m[0][2], 0.0));\n    assert(eq(m.m[0][3], 0.0));\n\n    assert(eq(m.m[1][0], 0.0));\n    assert(eq(m.m[1][1], 2.30940));\n    assert(eq(m.m[1][2], 0.0));\n    assert(eq(m.m[1][3], 0.0));\n\n    assert(eq(m.m[2][0], 0.0));\n    assert(eq(m.m[2][1], 0.0));\n    assert(eq(m.m[2][2], -1.00200));\n    assert(eq(m.m[2][3], -1.0));\n\n    assert(eq(m.m[3][0], 0.0));\n    assert(eq(m.m[3][1], 0.0));\n    assert(eq(m.m[3][2], -0.02002));\n    assert(eq(m.m[3][3], 0.0));\n}\n\ntest \"Mat4.lookat\" {\n    const m = Mat4.lookat(.{ .x = 0.0, .y = 1.5, .z = 6.0 }, Vec3.zero(), Vec3.up());\n\n    assert(eq(m.m[0][0], 1.0));\n    assert(eq(m.m[0][1], 0.0));\n    assert(eq(m.m[0][2], 0.0));\n    assert(eq(m.m[0][3], 0.0));\n\n    assert(eq(m.m[1][0], 0.0));\n    assert(eq(m.m[1][1], 0.97014));\n    assert(eq(m.m[1][2], 0.24253));\n    assert(eq(m.m[1][3], 0.0));\n\n    assert(eq(m.m[2][0], 0.0));\n    assert(eq(m.m[2][1], -0.24253));\n    assert(eq(m.m[2][2], 0.97014));\n    assert(eq(m.m[2][3], 0.0));\n\n    assert(eq(m.m[3][0], 0.0));\n    assert(eq(m.m[3][1], 0.0));\n    assert(eq(m.m[3][2], -6.18465));\n    assert(eq(m.m[3][3], 1.0));\n}\n\ntest \"Mat4.rotate\" {\n    const m = Mat4.rotate(2.0, .{ .x = 0.0, .y = 1.0, .z = 0.0 });\n\n    assert(eq(m.m[0][0], 0.99939));\n    assert(eq(m.m[0][1], 0.0));\n    assert(eq(m.m[0][2], -0.03489));\n    assert(eq(m.m[0][3], 0.0));\n\n    assert(eq(m.m[1][0], 0.0));\n    assert(eq(m.m[1][1], 1.0));\n    assert(eq(m.m[1][2], 0.0));\n    assert(eq(m.m[1][3], 0.0));\n\n    assert(eq(m.m[2][0], 0.03489));\n    assert(eq(m.m[2][1], 0.0));\n    assert(eq(m.m[2][2], 0.99939));\n    assert(eq(m.m[2][3], 0.0));\n\n    assert(eq(m.m[3][0], 0.0));\n    assert(eq(m.m[3][1], 0.0));\n    assert(eq(m.m[3][2], 0.0));\n    assert(eq(m.m[3][3], 1.0));\n}\n"
                        "math.zig" nil nil nil
                        "/Users/corysmith/workspace/zig/c-engine/src/util/math.zig"
                        nil nil)))


;;; Do not edit! File generated at Thu Apr 24 02:29:32 2025
